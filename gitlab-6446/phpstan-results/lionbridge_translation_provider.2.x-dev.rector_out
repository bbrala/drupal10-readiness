modules/contrib/lionbridge_translation_provider/src/Plugin/tmgmt/Translator/LionbridgeTranslator.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/TokenApi.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/JobStats.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/TranslationContent.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/KeyValuePair.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/UpdateJob.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/LanguagePairs.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/UpdateRequestsFile.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/UpdateRequestsKeyValue.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/Listener.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/ObjectSerializer.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/ListenerAuthEnum.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/ListenerRequest.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/ListenerTypeEnum.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/ModelInterface.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/Provider.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/TranslationContentApi.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/ProviderId.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/Request.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Annotation/FormatPlugin.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/ContentApiTranslatorUI.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Util/ConentApiHelper.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/RequestCtt.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/TranslationMemoryApi.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/SourceFile.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Util/GeneralHelper.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/SourceFileCtt.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/StatusCode.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/StatusCodeEnum.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/StatusUpdate.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/ApiException.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Configuration.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/tmgmt_contentapi.module
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/StatusUpdateCtt.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/HeaderSelector.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/ArrayOfRequestIds.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/SupportAsset.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/ArrayOfRequestIdsNote.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/Capabilities.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/Token.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/CreateJob.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/CreateListener.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/CreateRequestFile.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/CreateRequestFileCtt.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/CreateRequestKeyValue.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/CreateRequestUpdateTM.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/CreateSupportAsset.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/CreateToken.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/Error.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/Job.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Model/JobCtt.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Format/FormatInterface.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Format/FormatManager.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Plugin/tmgmt/Translator/ContentApiTranslator.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Plugin/tmgmt_contentapi/Format/Xliff.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Plugin/views/field/JobLioxidField.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Plugin/views/field/JobProvideridField.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Plugin/views/field/JobStatusField.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Plugin/views/filter/LioxJobIdFilter.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Plugin/views/filter/LioxJobstatusFilter.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/RecursiveDOMIterator.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/FileApi.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/JobApi.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/ProviderApi.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/RequestApi.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/SourceFileApi.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/StatusUpdateApi.php
modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/SupportAssetApi.php

15 files with changes
=====================

1) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/TranslationMemoryApi.php:27

    ---------- begin diff ----------
@@ @@

 namespace Drupal\tmgmt_contentapi\Swagger\Client\Api;

+use function GuzzleHttp\json_encode;
+use function GuzzleHttp\Psr7\build_query;
 use GuzzleHttp\Client;
 use GuzzleHttp\ClientInterface;
 use GuzzleHttp\Exception\RequestException;
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'POST',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector


2) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/TranslationContentApi.php:27

    ---------- begin diff ----------
@@ @@

 namespace Drupal\tmgmt_contentapi\Swagger\Client\Api;

+use function GuzzleHttp\json_encode;
+use function GuzzleHttp\Psr7\build_query;
 use GuzzleHttp\Client;
 use GuzzleHttp\ClientInterface;
 use GuzzleHttp\Exception\RequestException;
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector


3) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/TokenApi.php:27

    ---------- begin diff ----------
@@ @@

 namespace Drupal\tmgmt_contentapi\Swagger\Client\Api;

+use function GuzzleHttp\json_encode;
+use function GuzzleHttp\Psr7\build_query;
 use GuzzleHttp\Client;
 use GuzzleHttp\ClientInterface;
 use GuzzleHttp\Exception\RequestException;
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'POST',
             $this->config->getHost1() . $resourcePath . ($query ? "?{$query}" : ''),
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector


4) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/tmgmt_contentapi.module:0

    ---------- begin diff ----------
@@ @@
-<?php /** @noinspection PhpUnusedParameterInspection */
+<?php use Drupal\Core\Render\Markup;
+use Drupal\tmgmt_contentapi\Swagger\Client\ApiException;
+use Drupal\views\ViewExecutable;
+use Drupal\Core\Link;
+use Drupal\Core\Url;
+use Drupal\tmgmt\TranslatorPluginInterface;
+use Drupal\Core\Entity\EntityInterface;
+/** @noinspection PhpUnusedParameterInspection */

 use Drupal\Core\Form\FormStateInterface;
 use Drupal\Component\Utility\Xss;
@@ @@
           $labelname = $joblabel;
           $name = $labelname . "_" . $job->id() . "_all_"  . $job->getRemoteSourceLanguage() . '_' . $job->getRemoteTargetLanguage() . '.xlf';
           $jobpath = $allfilespath . "/" . $name;
-          $file = file_save_data($exporter->export($job), $jobpath, \Drupal\Core\File\FileSystemInterface::EXISTS_REPLACE);
+          $file = \Drupal::service('file.repository')->writeData($exporter->export($job), $jobpath, FileSystemInterface::EXISTS_REPLACE);
           $filearraytodelte[] = $file;
           $filearrayexportedfiles['all'] = $file;
         }
@@ @@
             $labelname = GeneralHelper::getStringNoSpeChars($item->label());
             $name = $labelname . "_" . $job->id() . "_" . $item->id() . "_" . $job->getRemoteSourceLanguage() . '_' . $job->getRemoteTargetLanguage() . '.xlf';
             $itempath = $allfilespath . "/" . $name;
-            $file = file_save_data($exporter->exportItem($item), $itempath, \Drupal\Core\File\FileSystemInterface::EXISTS_REPLACE);
+            $file = \Drupal::service('file.repository')->writeData($exporter->exportItem($item), $itempath, FileSystemInterface::EXISTS_REPLACE);
             $filearraytodelte[] = $file;
             $filearrayexportedfiles[$item->id()] = $file;
           }
@@ @@
         foreach ($filearraytodelte as $tempfile) {
           \Drupal::service('file_system')->delete($tempfile->getFileUri());
         }
-        $messageTopass .= '<a href="' . file_create_url($zipPath) . '">' . Xss::filter(GeneralHelper::getJobLabelNoSpeChars($job)) . '</a>';
-        \Drupal::messenger()->addMessage(\Drupal\Core\Render\Markup::create($messageTopass));
+        $messageTopass .= '<a href="' . \Drupal::service('file_url_generator')->generateAbsoluteString($zipPath) . '">' . Xss::filter(GeneralHelper::getJobLabelNoSpeChars($job)) . '</a>';
+        \Drupal::messenger()->addMessage(Markup::create($messageTopass));
       }
       else {
         throw new \Exception("Could not create directory for export: " . $allfilespath);
@@ @@
     $dirname = dirname($path);
     //\Drupal::service('file_system')->prepareDirectory($dirname, FileSystemInterface::CREATE_DIRECTORY);
     if (\Drupal::service('file_system')->prepareDirectory($dirname, FileSystemInterface::CREATE_DIRECTORY)) {
-      $file = file_save_data($filedatastring, $path, \Drupal\Core\File\FileSystemInterface::EXISTS_REPLACE);
+      $file = \Drupal::service('file.repository')->writeData($filedatastring, $path, FileSystemInterface::EXISTS_REPLACE);
       $mimetype = $file->getMimeType();//\Drupal::service('file.mime_type.guesser')->guess($path);
       $filearray = null;
       if ($mimetype == 'application/zip') {
@@ @@
           if ($ziparchive->extractTo(\Drupal::service('file_system')->realpath($pathtoextract))) {
             $ziparchive->close();
             $file->delete();
-            $filearray = CpcreateFileObjectFromStdClass(file_scan_directory($pathtoextract, '/.*\.xlf$/'));
+            $filearray = CpcreateFileObjectFromStdClass(\Drupal::service('file_system')->scanDirectory($pathtoextract, '/.*\.xlf$/'));
           }

         }
@@ @@
       $capijobid = isset($requestobjs[0]) && count($requestobjs) > 0 ? $requestobjs[0]->getJobId() : NULL;
     }
     
-    if($capijobid != NULL && $job->getState() > \Drupal\tmgmt\Entity\Job::STATE_UNPROCESSED) {
+    if($capijobid != NULL && $job->getState() > Job::STATE_UNPROCESSED) {
      $jobapi = new JobApi();  
      $capiVersion = 1;
       try{
@@ @@
         $projectInfo = $jobapi->jobsJobIdGetCtt($cttToken, $capijobid, "fullWithStats");
         $provider = $projectInfo->getProviderId();
         $jobstatus = 'IMPORTED';//$projectInfo->getStatusCode()->getStatusCode();
-        \Drupal\tmgmt_contentapi\Util\ConentApiHelper::capiJobSetStoredData($job, ['jobId' => $capijobid ,'jobStatus' => $jobstatus, 'providerId' => $provider, 'jobType' => $capiVersion]);
+        ConentApiHelper::capiJobSetStoredData($job, ['jobId' => $capijobid ,'jobStatus' => $jobstatus, 'providerId' => $provider, 'jobType' => $capiVersion]);
       }
       catch(Exception $ex){

@@ @@
   }
   catch (Exception $exception){
     $respbody = $exception->getMessage();
-    if($exception instanceof \Drupal\tmgmt_contentapi\Swagger\Client\ApiException){
+    if($exception instanceof ApiException){
       $respbody = $exception->getResponseBody();
     }
     $respbody = 'An error occured while fetching and importing files: '.$respbody;
@@ @@
     ->condition('uri', $uri)
     ->execute();
   if ($fids) {
-    $files = \Drupal\file\Entity\File::loadMultiple($fids);
+    $files = File::loadMultiple($fids);
     foreach ($files as $item) {
       // Since some database servers sometimes use a case-insensitive comparison
       // by default, double check that the filename is an exact match.
@@ @@
 }


-function tmgmt_contentapi_views_pre_view(Drupal\views\ViewExecutable $view) {
+function tmgmt_contentapi_views_pre_view(ViewExecutable $view) {

   if ($view->id() == 'tmgmt_job_overview') {
     $deliveryhtml = '';
@@ @@
       global $base_url;
       // Using Id here, as job label returns @title@title and @more more.
       $joblable = GeneralHelper::getJobLabel($job);
-      $pass_link = \Drupal::l(t($joblable), \Drupal\Core\Url::fromUri($base_url . '/admin/tmgmt/jobs/' . $jobid['value']));
+      $pass_link = Link::fromTextAndUrl(t($joblable), Url::fromUri($base_url . '/admin/tmgmt/jobs/' . $jobid['value']));
       $currentlink = $pass_link->getGeneratedLink();

       $deliveryhtml .= '<li>'.$currentlink .'</li>';
@@ @@
 }


-function tmgmt_contentapi_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id){
+function tmgmt_contentapi_form_alter(&$form, FormStateInterface $form_state, $form_id){
   /*
   $myForm = $form;
   if($form_id == 'views_exposed_form'){
@@ @@
   }
 }

-function canCustomTranslate(TranslatorInterface $translator, JobInterface $job, \Drupal\tmgmt\TranslatorPluginInterface $plugin) {
+function canCustomTranslate(TranslatorInterface $translator, JobInterface $job, TranslatorPluginInterface $plugin) {
   $job_state = $job->getState();
   $capisettings = $translator->getSetting('capi-settings');
   $capi = new TokenApi();
@@ @@
   }
 }

-function tmgmt_contentapi_entity_operation_alter(array &$operations,\Drupal\Core\Entity\EntityInterface  $entity) {
+function tmgmt_contentapi_entity_operation_alter(array &$operations,EntityInterface  $entity) {
   /*
   $newop = $operations['manage'];
   if(!isset($operations['updatestatus'])){
@@ @@
             $msg = substr($msg,0,200);
       }
       \Drupal::messenger()->addMessage($msg);
-		
+
       //\Drupal::messenger()->addMessage($e->getMessage());
     }
   }
    ----------- end diff -----------

Applied rules:
 * DrupalLRector
 * FileSaveDataRector
 * FileScanDirectoryRector
 * FileCreateUrlRector
 * ArgumentRemoverRector


5) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Util/GeneralHelper.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\tmgmt_contentapi\Util;

+use Drupal\tmgmt\Entity\JobItem;
 use Drupal\file\FileInterface;
 use Drupal\tmgmt\Entity\Job;
 use Drupal\tmgmt\JobInterface;
@@ @@
       $groups = $loadedxml->xpath("//xliff:group[@id='" . $tjiid ."']");
       if(count($groups) == 1){
         $item->setState(Job::STATE_ACTIVE);
-        $job->setState(\Drupal\tmgmt\Entity\JobItem::STATE_ACTIVE);
+        $job->setState(JobItem::STATE_ACTIVE);
       }
     }
   }
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector


6) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/SupportAssetApi.php:27

    ---------- begin diff ----------
@@ @@

 namespace Drupal\tmgmt_contentapi\Swagger\Client\Api;

+use function GuzzleHttp\json_encode;
+use function GuzzleHttp\Psr7\build_query;
 use GuzzleHttp\Client;
 use GuzzleHttp\ClientInterface;
 use GuzzleHttp\Exception\RequestException;
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'POST',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'DELETE',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector


7) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/StatusUpdateApi.php:27

    ---------- begin diff ----------
@@ @@

 namespace Drupal\tmgmt_contentapi\Swagger\Client\Api;

+use function GuzzleHttp\json_encode;
+use function GuzzleHttp\Psr7\build_query;
 use GuzzleHttp\Client;
 use GuzzleHttp\ClientInterface;
 use GuzzleHttp\Exception\RequestException;
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost1() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'DELETE',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'POST',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost1() . $resourcePath . ($query ? "?{$query}" : ''),
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector


8) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/SourceFileApi.php:27

    ---------- begin diff ----------
@@ @@

 namespace Drupal\tmgmt_contentapi\Swagger\Client\Api;

+use function GuzzleHttp\json_encode;
+use function GuzzleHttp\Psr7\build_query;
 use GuzzleHttp\Client;
 use GuzzleHttp\ClientInterface;
 use GuzzleHttp\Exception\RequestException;
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'POST',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector


9) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/RequestApi.php:27

    ---------- begin diff ----------
@@ @@

 namespace Drupal\tmgmt_contentapi\Swagger\Client\Api;

+use function GuzzleHttp\json_encode;
+use function GuzzleHttp\Psr7\build_query;
 use GuzzleHttp\Client;
 use GuzzleHttp\ClientInterface;
 use GuzzleHttp\Exception\RequestException;
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'POST',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'POST',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost1() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost1() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'DELETE',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector


10) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/ProviderApi.php:27

    ---------- begin diff ----------
@@ @@

 namespace Drupal\tmgmt_contentapi\Swagger\Client\Api;

+use function GuzzleHttp\json_encode;
+use function GuzzleHttp\Psr7\build_query;
 use GuzzleHttp\Client;
 use GuzzleHttp\ClientInterface;
 use GuzzleHttp\Exception\RequestException;
@@ @@
           $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
         );
       }
-      
+
       $statusCode = $response->getStatusCode();

       if ($statusCode < 200 || $statusCode > 299) {
@@ @@
       $httpBody = $_tempBody;
       // \stdClass has no __toString(), so we should encode it manually
       if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-        $httpBody = \GuzzleHttp\json_encode($httpBody);
+        $httpBody = json_encode($httpBody);
       }
     } elseif (count($formParams) > 0) {
       if ($multipart) {
@@ @@
         $httpBody = new MultipartStream($multipartContents);

       } elseif ($headers['Content-Type'] === 'application/json') {
-        $httpBody = \GuzzleHttp\json_encode($formParams);
+        $httpBody = json_encode($formParams);

       } else {
         // for HTTP post (form)
-        $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+        $httpBody = build_query($formParams);
       }
     }

@@ @@
       $headers
     );

-    $query = \GuzzleHttp\Psr7\build_query($queryParams);
+    $query = build_query($queryParams);
     return new Request(
       'GET',
       $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
       $httpBody = $_tempBody;
       // \stdClass has no __toString(), so we should encode it manually
       if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-        $httpBody = \GuzzleHttp\json_encode($httpBody);
+        $httpBody = json_encode($httpBody);
       }
     } elseif (count($formParams) > 0) {
       if ($multipart) {
@@ @@
         $httpBody = new MultipartStream($multipartContents);

       } elseif ($headers['Content-Type'] === 'application/json') {
-        $httpBody = \GuzzleHttp\json_encode($formParams);
+        $httpBody = json_encode($formParams);

       } else {
         // for HTTP post (form)
-        $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+        $httpBody = build_query($formParams);
       }
     }

@@ @@
       $headers
     );

-    $query = \GuzzleHttp\Psr7\build_query($queryParams);
+    $query = build_query($queryParams);
     return new Request(
       'GET',
       $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
       $httpBody = $_tempBody;
       // \stdClass has no __toString(), so we should encode it manually
       if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-        $httpBody = \GuzzleHttp\json_encode($httpBody);
+        $httpBody = json_encode($httpBody);
       }
     } elseif (count($formParams) > 0) {
       if ($multipart) {
@@ @@
         $httpBody = new MultipartStream($multipartContents);

       } elseif ($headers['Content-Type'] === 'application/json') {
-        $httpBody = \GuzzleHttp\json_encode($formParams);
+        $httpBody = json_encode($formParams);

       } else {
         // for HTTP post (form)
-        $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+        $httpBody = build_query($formParams);
       }
     }

@@ @@
       $headers
     );

-    $query = \GuzzleHttp\Psr7\build_query($queryParams);
+    $query = build_query($queryParams);
     return new Request(
       'GET',
       $this->config->getHost1() . $resourcePath . ($query ? "?{$query}" : ''),
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector


11) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/JobApi.php:27

    ---------- begin diff ----------
@@ @@

 namespace Drupal\tmgmt_contentapi\Swagger\Client\Api;

+use function GuzzleHttp\json_encode;
+use function GuzzleHttp\Psr7\build_query;
 use GuzzleHttp\Client;
 use GuzzleHttp\ClientInterface;
 use GuzzleHttp\Exception\RequestException;
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost1() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'DELETE',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost1() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'PUT',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'POST',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector


12) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Swagger/Client/Api/FileApi.php:28

    ---------- begin diff ----------
@@ @@
 namespace Drupal\tmgmt_contentapi\Swagger\Client\Api;


+use function GuzzleHttp\json_encode;
+use function GuzzleHttp\Psr7\build_query;
 use GuzzleHttp\Client;
 use GuzzleHttp\ClientInterface;
 use GuzzleHttp\Exception\RequestException;
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
@@ @@
             $httpBody = $_tempBody;
             // \stdClass has no __toString(), so we should encode it manually
             if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($httpBody);
+                $httpBody = json_encode($httpBody);
             }
         } elseif (count($formParams) > 0) {
             if ($multipart) {
@@ @@
                 $httpBody = new MultipartStream($multipartContents);

             } elseif ($headers['Content-Type'] === 'application/json') {
-                $httpBody = \GuzzleHttp\json_encode($formParams);
+                $httpBody = json_encode($formParams);

             } else {
                 // for HTTP post (form)
-                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
+                $httpBody = build_query($formParams);
             }
         }

@@ @@
             $headers
         );

-        $query = \GuzzleHttp\Psr7\build_query($queryParams);
+        $query = build_query($queryParams);
         return new Request(
             'GET',
             $this->config->getHost1() . $resourcePath . ($query ? "?{$query}" : ''),
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector


13) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Plugin/views/field/JobProvideridField.php:175

    ---------- begin diff ----------
@@ @@
       $capisettings = $translator->getSetting('capi-settings');
       $capi = new TokenApi();
       $token = $capi->getToken($capisettings['capi_username_ctt'],$capisettings['capi_password_ctt']);
-      
-  
+
+
         if(isset($token) && $token != '') {
             $providersarray = array();
             try {
               $providerapi = new ProviderApi();
               $providers = $providerapi->providersGet($token);
-              
+
               foreach ($providers as $provider) {
                 $prid = $provider->getProviderId();
                 $prname = $provider->getProviderName();
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector
 * ChangeMethodVisibilityRector


14) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/Plugin/tmgmt/Translator/ContentApiTranslator.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\tmgmt_contentapi\Plugin\tmgmt\Translator;

+use Drupal\Core\Render\Markup;
+use Drupal\node\Entity\Node;
+use Drupal\file\Entity\File;
 use Drupal\Component\Utility\Xss;

 use Drupal\Core\Entity\Entity;
@@ @@
     if ($jobtranslatorId == 'contentapi') {
       $source = $this->requestTranslationSource($job);
     }
-    
+
     //return $source;
   }

@@ @@
             $labelname = $joblabel;
             $name = $labelname . "_" . $job->id() . "_all_"  . $job->getRemoteSourceLanguage() . '_' . $job->getRemoteTargetLanguage() . '.xlf';
             $jobpath = $allfilespath . "/" . $name;
-            $file = file_save_data($exporter->export($job), $jobpath, \Drupal\Core\File\FileSystemInterface::EXISTS_REPLACE);
+            $file = \Drupal::service('file.repository')->writeData($exporter->export($job), $jobpath, FileSystemInterface::EXISTS_REPLACE);
             $filearraytodelte[] = $file;
             $filearrayexportedfiles['all'] = $file;
           }
@@ @@
               $labelname = GeneralHelper::getStringNoSpeChars($item->label());
               $name = $labelname . "_" . $job->id() . "_" . $item->id() . "_" . $job->getRemoteSourceLanguage() . '_' . $job->getRemoteTargetLanguage() . '.xlf';
               $itempath = $allfilespath . "/" . $name;
-              $file = file_save_data($exporter->exportItem($item), $itempath, \Drupal\Core\File\FileSystemInterface::EXISTS_REPLACE);
+              $file = \Drupal::service('file.repository')->writeData($exporter->exportItem($item), $itempath, FileSystemInterface::EXISTS_REPLACE);
               $filearraytodelte[] = $file;
               $filearrayexportedfiles[$item->id()] = $file;
             }
@@ @@
             // TODO
             // Add content api bundle to job's settings.
             GeneralHelper::addCpaSettingsToJob($job, serialize($contentapibundle));
-            $messageTopass .= '<a href="' . file_create_url($zipPath) . '">' . Xss::filter(GeneralHelper::getJobLabelNoSpeChars($job)) . '</a>';
-            \Drupal::messenger()->addMessage(\Drupal\Core\Render\Markup::create($messageTopass));
+            $messageTopass .= '<a href="' . \Drupal::service('file_url_generator')->generateAbsoluteString($zipPath) . '">' . Xss::filter(GeneralHelper::getJobLabelNoSpeChars($job)) . '</a>';
+            \Drupal::messenger()->addMessage(Markup::create($messageTopass));
             if($job->getSetting('capi-settings')['quote']['is_quote']){
               $job->submitted("This job was submitted for a quote. To submit your job for processing, you must log into your translation provider's system to approve this quote.");
             }
@@ @@
             }
             $projectInfo = $jobsubmitresult;

-            \Drupal\tmgmt_contentapi\Util\ConentApiHelper::capiJobSetStoredData($job, ['jobId' => $projectInfo->getJobId() ,'jobStatus' => $projectInfo->getStatusCode(), 'providerId' => $projectInfo->getProviderId(), 'jobType' => 2]);
+            ConentApiHelper::capiJobSetStoredData($job, ['jobId' => $projectInfo->getJobId() ,'jobStatus' => $projectInfo->getStatusCode(), 'providerId' => $projectInfo->getProviderId(), 'jobType' => 2]);
             
           }
         }
@@ @@
             $labelname = $joblabel;
             $name = $labelname . "_" . $job->id() . "_all_"  . $job->getRemoteSourceLanguage() . '_' . $job->getRemoteTargetLanguage() . '.xlf';
             $jobpath = $allfilespath . "/" . $name;
-            $file = file_save_data($exporter->export($job), $jobpath, \Drupal\Core\File\FileSystemInterface::EXISTS_REPLACE);
+            $file = \Drupal::service('file.repository')->writeData($exporter->export($job), $jobpath, FileSystemInterface::EXISTS_REPLACE);
             $filearraytodelte[] = $file;
             $filearrayexportedfiles['all'] = $file;
           }
@@ @@
               $labelname = GeneralHelper::getStringNoSpeChars($item->label());
               $name = $labelname . "_" . $job->id() . "_" . $item->id() . "_" . $job->getRemoteSourceLanguage() . '_' . $job->getRemoteTargetLanguage() . '.xlf';
               $itempath = $allfilespath . "/" . $name;
-              $file = file_save_data($exporter->exportItem($item), $itempath, \Drupal\Core\File\FileSystemInterface::EXISTS_REPLACE);
+              $file = \Drupal::service('file.repository')->writeData($exporter->exportItem($item), $itempath, FileSystemInterface::EXISTS_REPLACE);
               $filearraytodelte[] = $file;
               $filearrayexportedfiles[$item->id()] = $file;
             }
@@ @@
           if ($jobsubmitresult) {
             // TODO
             GeneralHelper::addCpaSettingsToJob($job, serialize($contentapibundle));
-            $messageTopass .= '<a href="' . file_create_url($zipPath) . '">' . Xss::filter(GeneralHelper::getJobLabelNoSpeChars($job)) . '</a>';
-            \Drupal::messenger()->addMessage(\Drupal\Core\Render\Markup::create($messageTopass));
+            $messageTopass .= '<a href="' . \Drupal::service('file_url_generator')->generateAbsoluteString($zipPath) . '">' . Xss::filter(GeneralHelper::getJobLabelNoSpeChars($job)) . '</a>';
+            \Drupal::messenger()->addMessage(Markup::create($messageTopass));
             //set job to finished
             $job->setState(Job::STATE_FINISHED);
             foreach ($job->getItems() as $item){
@@ @@
               //node id
               $nodeid = $item->getFields()["item_id"][0]->getValue()["value"];
               //to get target id
-              if(\Drupal\node\Entity\Node::load($nodeid) == null){
+              if(Node::load($nodeid) == null){
                 continue;
               }
-              if(!\Drupal\node\Entity\Node::load($nodeid)->hasField("field_reference")){
+              if(!Node::load($nodeid)->hasField("field_reference")){
                 continue;
               }

-              if(sizeof(\Drupal\node\Entity\Node::load($nodeid)->getFields()["field_reference"]->getValue()) == 0){
+              if(sizeof(Node::load($nodeid)->getFields()["field_reference"]->getValue()) == 0){
                 continue;
               }
               
               //to get target id
-              $targetid = \Drupal\node\Entity\Node::load($nodeid)->getFields()["field_reference"]->getValue()[0]["target_id"];
+              $targetid = Node::load($nodeid)->getFields()["field_reference"]->getValue()[0]["target_id"];
               
               if($targetid == null)
               {
@@ @@
               }

               //ref url
-              $refFile = \Drupal\file\Entity\File::load($targetid);
+              $refFile = File::load($targetid);

               //$file = file_save_data($exporter->exportItem($item), $itempath, \Drupal\Core\File\FileSystemInterface::EXISTS_REPLACE);
               //$filearraytodelte[] = $file;
@@ @@
             $labelname = $joblabel;
             $name = $labelname . "_" . $job->id() . "_all_"  . $job->getRemoteSourceLanguage() . '_' . $job->getRemoteTargetLanguage() . '.xlf';
             $jobpath = $allfilespath . "/" . $name;
-            $file = file_save_data($exporter->export($job), $jobpath, \Drupal\Core\File\FileSystemInterface::EXISTS_REPLACE);
+            $file = \Drupal::service('file.repository')->writeData($exporter->export($job), $jobpath, FileSystemInterface::EXISTS_REPLACE);
             $filearraytodelte[] = $file;
             $filearrayexportedfiles['all'] = $file;
           }
@@ @@
               $labelname = GeneralHelper::getStringNoSpeChars($item->label());
               $name = $labelname . "_" . $job->id() . "_" . $item->id() . "_" . $job->getRemoteSourceLanguage() . '_' . $job->getRemoteTargetLanguage() . '.xlf';
               $itempath = $allfilespath . "/" . $name;
-              $file = file_save_data($exporter->exportItem($item), $itempath, \Drupal\Core\File\FileSystemInterface::EXISTS_REPLACE);
+              $file = \Drupal::service('file.repository')->writeData($exporter->exportItem($item), $itempath, FileSystemInterface::EXISTS_REPLACE);
               $filearraytodelte[] = $file;
               $filearrayexportedfiles[$item->id()] = $file;
             }
@@ @@
           if ($jobsubmitresult) {
             // TODO
             GeneralHelper::addCpaSettingsToJob($job, serialize($contentapibundle));
-            $messageTopass .= '<a href="' . file_create_url($zipPath) . '">' . Xss::filter(GeneralHelper::getJobLabelNoSpeChars($job)) . '</a>';
-            \Drupal::messenger()->addMessage(\Drupal\Core\Render\Markup::create($messageTopass));
+            $messageTopass .= '<a href="' . \Drupal::service('file_url_generator')->generateAbsoluteString($zipPath) . '">' . Xss::filter(GeneralHelper::getJobLabelNoSpeChars($job)) . '</a>';
+            \Drupal::messenger()->addMessage(Markup::create($messageTopass));
             //set job to finished
             $job->setState(Job::STATE_FINISHED);
             foreach ($job->getItems() as $item){
@@ @@
     $dirname = dirname($path);

     if (\Drupal::service('file_system')->prepareDirectory($dirname, FileSystemInterface::CREATE_DIRECTORY)) {
-      $file = file_save_data($export->export($job), $path);
+      $file = \Drupal::service('file.repository')->writeData($export->export($job), $path);
       \Drupal::service('file.usage')->add($file, 'tmgmt_fwconnector', 'tmgmt_job', $job->id());
-      $job->submitted('Exported file can be downloaded <a href="@link">here</a>.', array('@link' => file_create_url($path)));
+      $job->submitted('Exported file can be downloaded <a href="@link">here</a>.', array('@link' => \Drupal::service('file_url_generator')->generateAbsoluteString($path)));
     }
   }
    ----------- end diff -----------

Applied rules:
 * FileSaveDataRector
 * FileCreateUrlRector
 * ArgumentRemoverRector
 * WrapReturnRector


15) modules/contrib/lionbridge_translation_provider/tmgmt_contentapi/src/ContentApiTranslatorUI.php:530

    ---------- begin diff ----------
@@ @@
       $tokenobj = $capi->oauth2TokenPost($tokenrequest);
     }
     $capiVersion = 2;
-    If($job->getState() > \Drupal\tmgmt\Entity\Job::STATE_UNPROCESSED) {
+    If($job->getState() > Job::STATE_UNPROCESSED) {
  
       $jobapi = new JobApi();

@@ @@
               }    
             } catch (Exception $e) {

-		
+
 				$msg = $e->getMessage();
 		      	if(strlen($msg) > 200){
 		            $msg = substr($msg,0,200);
@@ @@
           }
           
         }
-        \Drupal\tmgmt_contentapi\Util\ConentApiHelper::capiJobSetStoredData($job, ['jobId' => $capijobid ,'jobStatus' => $jobstatus, 'providerId' => $prid, 'jobType' => $capiVersion]);
+        ConentApiHelper::capiJobSetStoredData($job, ['jobId' => $capijobid ,'jobStatus' => $jobstatus, 'providerId' => $prid, 'jobType' => $capiVersion]);
         
         if($jobstatus == StatusCodeEnum::REVIEW_TRANSLATION){
-          $updatedremotejob = \Drupal\tmgmt_contentapi\Util\ConentApiHelper::checkJobFinishAndApproveRemote($job);
+          $updatedremotejob = ConentApiHelper::checkJobFinishAndApproveRemote($job);
           $projectInfo = $updatedremotejob != NULL ? $updatedremotejob:$projectInfo;
         }
       }
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * WrapReturnRector


 [OK] 15 files have been changed by Rector                                      

