diff --git a/modules/permissions_by_entity/tests/src/Kernel/EntityAccessCheckTest.php b/modules/permissions_by_entity/tests/src/Kernel/EntityAccessCheckTest.php
index 7d3574f..eb560fb 100644
--- a/modules/permissions_by_entity/tests/src/Kernel/EntityAccessCheckTest.php
+++ b/modules/permissions_by_entity/tests/src/Kernel/EntityAccessCheckTest.php
@@ -70,7 +70,7 @@ class EntityAccessCheckTest extends KernelTestBase {
   /**
    * {@inheritdoc}
    */
-  public function setUp() {
+  public function setUp(): void {
     parent::setUp();
     $this->installEntitySchema('user');
     $this->installSchema('system', ['key_value_expire', 'sequences']);
@@ -105,17 +105,18 @@ class EntityAccessCheckTest extends KernelTestBase {
     $dispatcher = $this->getPopulatedDispatcher();
 
     $this->expectException(AccessDeniedHttpException::class);
-    $dispatcher->dispatch(KernelEvents::REQUEST, $this->getRequestEvent());
+    $dispatcher->dispatch($this->getRequestEvent(), KernelEvents::REQUEST);
   }
 
   /**
    * Tests even listener based access control.
+   * @doesNotPerformAssertions
    */
   public function testAuthenticatedAccessUsingKernel(): void {
     $dispatcher = $this->getPopulatedDispatcher();
 
     $this->container->get('current_user')->setAccount($this->terms['term_user_a']['user']);
-    $dispatcher->dispatch(KernelEvents::REQUEST, $this->getRequestEvent());
+    $dispatcher->dispatch($this->getRequestEvent(), KernelEvents::REQUEST);
   }
 
   /**
@@ -126,8 +127,8 @@ class EntityAccessCheckTest extends KernelTestBase {
 
     // Execute first request for allowed user.
     $this->container->get('current_user')->setAccount($this->terms['term_user_a']['user']);
-    $dispatcher->dispatch(KernelEvents::REQUEST, $this->getRequestEvent());
-    $dispatcher->dispatch(KernelEvents::RESPONSE, $this->getCacheableResponseEvent());
+    $dispatcher->dispatch($this->getRequestEvent(), KernelEvents::REQUEST);
+    $dispatcher->dispatch($this->getCacheableResponseEvent(), KernelEvents::RESPONSE);
 
     // Reset the cache to emulate a new request.
     $this->container->get('permissions_by_entity.checked_entity_cache')->clear();
@@ -135,7 +136,7 @@ class EntityAccessCheckTest extends KernelTestBase {
     // Execute second request for disallowed user.
     $this->container->get('current_user')->setAccount($this->terms['term_user_b']['user']);
     $this->expectException(AccessDeniedHttpException::class);
-    $dispatcher->dispatch(KernelEvents::REQUEST, $this->getRequestEvent());
+    $dispatcher->dispatch($this->getRequestEvent(), KernelEvents::REQUEST);
   }
 
   /**
diff --git a/modules/permissions_by_entity/tests/src/Kernel/EntityPublicationTest.php b/modules/permissions_by_entity/tests/src/Kernel/EntityPublicationTest.php
index 3cb7f7e..72a8cbb 100644
--- a/modules/permissions_by_entity/tests/src/Kernel/EntityPublicationTest.php
+++ b/modules/permissions_by_entity/tests/src/Kernel/EntityPublicationTest.php
@@ -45,7 +45,7 @@ class EntityPublicationTest extends KernelTestBase {
   /**
    * {@inheritdoc}
    */
-  public function setUp() {
+  public function setUp(): void {
     parent::setUp();
     $this->installEntitySchema('test_entity');
     $this->installEntitySchema('user');
@@ -74,7 +74,7 @@ class EntityPublicationTest extends KernelTestBase {
   public function testAnonymousCanViewPublishedNodesWithoutTermPermissions(): void {
     $this->assertTrue($this->nodes['node_published']->isPublished());
     $this->assertEquals(AccessResult::neutral(), permissions_by_entity_entity_access($this->nodes['node_published'], 'view', $this->anonymousUser));
-    $this->assertNotEqual(AccessResult::forbidden(), $this->nodes['node_published']->access('view', $this->anonymousUser, TRUE));
+    $this->assertNotEquals(AccessResult::forbidden(), $this->nodes['node_published']->access('view', $this->anonymousUser, TRUE));
   }
 
   /**
diff --git a/src/Event/PermissionsByTermDeniedEvent.php b/src/Event/PermissionsByTermDeniedEvent.php
index ad9ae58..1ab0e29 100644
--- a/src/Event/PermissionsByTermDeniedEvent.php
+++ b/src/Event/PermissionsByTermDeniedEvent.php
@@ -9,7 +9,7 @@ use Symfony\Component\EventDispatcher\Event;
  *
  * @package Drupal\permissions_by_term\Event
  */
-class PermissionsByTermDeniedEvent extends Event {
+class PermissionsByTermDeniedEvent extends \Symfony\Contracts\EventDispatcher\Event {
 
   const NAME = 'permissions_by_term.access.denied';
 
diff --git a/src/Listener/KernelEventListener.php b/src/Listener/KernelEventListener.php
index 520a70d..260a7bb 100644
--- a/src/Listener/KernelEventListener.php
+++ b/src/Listener/KernelEventListener.php
@@ -164,7 +164,7 @@ class KernelEventListener implements EventSubscriberInterface
       $node = $event->getRequest()->attributes->get('node');
       if (!$this->accessCheckService->canUserAccessByNode($node, false, $this->accessStorageService->getLangCode($node->id()))) {
         $accessDeniedEvent = new PermissionsByTermDeniedEvent($node->id());
-        $this->eventDispatcher->dispatch(PermissionsByTermDeniedEvent::NAME, $accessDeniedEvent);
+        $this->eventDispatcher->dispatch($accessDeniedEvent, PermissionsByTermDeniedEvent::NAME);
 
         if ($this->disabledNodeAccessRecords) {
           $this->pageCacheKillSwitch->trigger();
diff --git a/src/Service/AccessCheck.php b/src/Service/AccessCheck.php
index 4474444..6fc0ad8 100644
--- a/src/Service/AccessCheck.php
+++ b/src/Service/AccessCheck.php
@@ -235,7 +235,7 @@ class AccessCheck {
 
   private function dispatchDeniedEvent($nodeId): void {
     $accessDeniedEvent = new PermissionsByTermDeniedEvent($nodeId);
-    $this->eventDispatcher->dispatch(PermissionsByTermDeniedEvent::NAME, $accessDeniedEvent);
+    $this->eventDispatcher->dispatch($accessDeniedEvent, PermissionsByTermDeniedEvent::NAME);
   }
 
   public function isAnyTaxonomyTermFieldDefinedInNodeType(string $nodeType) {
