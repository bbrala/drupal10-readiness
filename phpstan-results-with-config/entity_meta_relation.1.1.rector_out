modules/contrib/entity_meta_relation/emr.install
modules/contrib/entity_meta_relation/emr.module
modules/contrib/entity_meta_relation/emr.post_update.php
modules/contrib/entity_meta_relation/modules/emr_node/emr_node.module
modules/contrib/entity_meta_relation/modules/emr_node/emr_node.post_update.php
modules/contrib/entity_meta_relation/modules/emr_node/src/NodeFormHandler.php
modules/contrib/entity_meta_relation/modules/entity_meta_example/entity_meta_example.install
modules/contrib/entity_meta_relation/modules/entity_meta_example/modules/entity_meta_audio/src/AudioEntityMetaWrapper.php
modules/contrib/entity_meta_relation/modules/entity_meta_example/modules/entity_meta_audio/src/Plugin/EntityMetaRelation/AudioConfiguration.php
modules/contrib/entity_meta_relation/modules/entity_meta_example/modules/entity_meta_force/src/ForceEntityMetaWrapper.php
modules/contrib/entity_meta_relation/modules/entity_meta_example/modules/entity_meta_force/src/Plugin/EntityMetaRelation/ForceConfiguration.php
modules/contrib/entity_meta_relation/modules/entity_meta_example/modules/entity_meta_speed/src/Plugin/EntityMetaRelation/SpeedConfiguration.php
modules/contrib/entity_meta_relation/modules/entity_meta_example/modules/entity_meta_speed/src/SpeedEntityMetaWrapper.php
modules/contrib/entity_meta_relation/modules/entity_meta_example/modules/entity_meta_visual/src/Plugin/EntityMetaRelation/VisualConfiguration.php
modules/contrib/entity_meta_relation/src/Annotation/EntityMetaRelation.php
modules/contrib/entity_meta_relation/src/ContentFormHandlerBase.php
modules/contrib/entity_meta_relation/src/ContentFormHandlerInterface.php
modules/contrib/entity_meta_relation/src/Entity/EntityMeta.php
modules/contrib/entity_meta_relation/src/Entity/EntityMetaInterface.php
modules/contrib/entity_meta_relation/src/Entity/EntityMetaRelation.php
modules/contrib/entity_meta_relation/src/Entity/EntityMetaRelationInterface.php
modules/contrib/entity_meta_relation/src/Entity/EntityMetaRelationType.php
modules/contrib/entity_meta_relation/src/Entity/EntityMetaType.php
modules/contrib/entity_meta_relation/src/Entity/Query/Sql/Query.php
modules/contrib/entity_meta_relation/src/Entity/Query/Sql/QueryFactory.php
modules/contrib/entity_meta_relation/src/EntityMetaListBuilder.php
modules/contrib/entity_meta_relation/src/EntityMetaRelationInstaller.php
modules/contrib/entity_meta_relation/src/EntityMetaRelationListBuilder.php
modules/contrib/entity_meta_relation/src/EntityMetaRelationStorage.php
modules/contrib/entity_meta_relation/src/EntityMetaRelationStorageInterface.php
modules/contrib/entity_meta_relation/src/EntityMetaRelationTypeListBuilder.php
modules/contrib/entity_meta_relation/src/EntityMetaStorage.php
modules/contrib/entity_meta_relation/src/EntityMetaStorageInterface.php
modules/contrib/entity_meta_relation/src/EntityMetaTypeListBuilder.php
modules/contrib/entity_meta_relation/src/EntityMetaWrapper.php
modules/contrib/entity_meta_relation/src/EntityMetaWrapperFactory.php
modules/contrib/entity_meta_relation/src/EntityMetaWrapperFactoryInterface.php
modules/contrib/entity_meta_relation/src/EntityMetaWrapperInterface.php
modules/contrib/entity_meta_relation/src/Exception/EntityMetaEmptyException.php
modules/contrib/entity_meta_relation/src/Field/ComputedEntityMetasItemList.php
modules/contrib/entity_meta_relation/src/Field/ComputedHostEntityItemList.php
modules/contrib/entity_meta_relation/src/Field/DefaultRevisionFieldItemList.php
modules/contrib/entity_meta_relation/src/Field/EntityMetaItemListInterface.php
modules/contrib/entity_meta_relation/src/Form/EntityMetaForm.php
modules/contrib/entity_meta_relation/src/Form/EntityMetaRelationForm.php
modules/contrib/entity_meta_relation/src/Form/EntityMetaRelationTypeForm.php
modules/contrib/entity_meta_relation/src/Form/EntityMetaTypeForm.php
modules/contrib/entity_meta_relation/src/Plugin/EntityMetaRelationContentFormPluginBase.php
modules/contrib/entity_meta_relation/src/Plugin/EntityMetaRelationContentFormPluginInterface.php
modules/contrib/entity_meta_relation/src/Plugin/EntityMetaRelationInlineContentFormPluginBase.php
modules/contrib/entity_meta_relation/src/Plugin/EntityMetaRelationPluginBase.php
modules/contrib/entity_meta_relation/src/Plugin/EntityMetaRelationPluginInterface.php
modules/contrib/entity_meta_relation/src/Plugin/EntityMetaRelationPluginManager.php
modules/contrib/entity_meta_relation/src/Plugin/Field/FieldType/BaseEntityMetaRelationItem.php
modules/contrib/entity_meta_relation/src/Plugin/Field/FieldType/EntityMetaRelationEntityMetaItem.php
modules/contrib/entity_meta_relation/src/Plugin/Field/FieldType/EntityMetaRelationHostEntityMetaItem.php
modules/contrib/entity_meta_relation/tests/features/bootstrap/FeatureContext.php
modules/contrib/entity_meta_relation/tests/src/Functional/EntityMetaRelationContentFormTest.php
modules/contrib/entity_meta_relation/tests/src/Kernel/EntityMetaRelationAttachByDefaultTest.php
modules/contrib/entity_meta_relation/tests/src/Kernel/EntityMetaRelationRevisionTest.php
modules/contrib/entity_meta_relation/tests/src/Kernel/EntityMetaRelationTest.php

36 files with changes
=====================

1) modules/contrib/entity_meta_relation/tests/src/Kernel/EntityMetaRelationTest.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\Tests\emr\Kernel;

+use Drupal\emr\EntityMetaStorageInterface;
+use Drupal\emr\EntityMetaRelationStorageInterface;
+use Drupal\node\NodeStorageInterface;
+use Drupal\emr\Entity\EntityMetaRelationInterface;
 use Drupal\emr\Entity\EntityMetaInterface;
 use Drupal\emr\Field\EntityMetaItemListInterface;
 use Drupal\KernelTests\KernelTestBase;
@@ @@
   /**
    * The entity meta storage.
    *
-   * @var \Drupal\emr\EntityMetaStorageInterface
+   * @var EntityMetaStorageInterface
    */
   protected $entityMetaStorage;

@@ @@
   /**
    * The entity meta relation storage.
    *
-   * @var \Drupal\emr\EntityMetaRelationStorageInterface
+   * @var EntityMetaRelationStorageInterface
    */
   protected $entityMetaRelationStorage;

@@ @@
   /**
    * The node storage.
    *
-   * @var \Drupal\node\NodeStorageInterface
+   * @var NodeStorageInterface
    */
   protected $nodeStorage;

@@ @@

     // We create a first node we don't use for anything to ensure we don't
     // have coincidental matching IDs between nodes and entity metas.
-    /** @var \Drupal\node\NodeInterface $first_node */
+    /** @var NodeInterface $first_node */
     $first_node = $this->nodeStorage->create([
       'type' => 'entity_meta_example_ct',
       'title' => 'First node',
@@ @@
    * Tests that entity meta can be correctly related to content entities (node).
    */
   public function testSingleEntityMetaRelations() {
-    /** @var \Drupal\node\NodeInterface $node */
+    /** @var NodeInterface $node */
     $node = $this->nodeStorage->create([
       'type' => 'entity_meta_example_ct',
       'title' => 'Second node',
@@ @@
     $this->assertEmpty($entity_meta_relations);

     // Manually create an entity meta for bundle "visual".
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+    /** @var EntityMetaInterface $entity_meta */
     $entity_meta = $this->entityMetaStorage->create([
       'bundle' => 'visual',
       'field_color' => 'red',
@@ @@
     // been created.
     $entity_meta_relations = $this->entityMetaRelationStorage->loadMultiple();
     $this->assertCount(1, $entity_meta_relations);
-    /** @var \Drupal\emr\Entity\EntityMetaRelationInterface $entity_meta_relation */
+    /** @var EntityMetaRelationInterface $entity_meta_relation */
     $entity_meta_relation = reset($entity_meta_relations);
     // Only one revision of the relation should have been made.
     $results = $this->entityMetaRelationStorage->getQuery()->allRevisions()->execute();
@@ @@
    * Tests that entity meta can be correctly related to content entities (node).
    */
   public function testMultipleEntityMetaRelations() {
-    /** @var \Drupal\node\NodeInterface $node */
+    /** @var NodeInterface $node */
     $node = $this->nodeStorage->create([
       'type' => 'entity_meta_multi_example_ct',
       'title' => 'Second node',
@@ @@
     $this->assertEmpty($entity_meta_relations);

     // Create entity meta for bundle "visual".
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta_visual */
+    /** @var EntityMetaInterface $entity_meta_visual */
     $entity_meta_visual = $this->entityMetaStorage->create([
       'bundle' => 'visual',
       'field_color' => 'red',
@@ @@
     $this->assertEquals('red', $entity_meta_visual->get('field_color')->value);

     // Create entity meta for bundle "audio".
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta_audio */
+    /** @var EntityMetaInterface $entity_meta_audio */
     $entity_meta_audio = $this->entityMetaStorage->create([
       'bundle' => 'audio',
       'field_volume' => 'low',
@@ @@
     $entity_meta_relations = $this->entityMetaRelationStorage->loadMultiple();
     $this->assertCount(2, $entity_meta_relations);
     // The first relation points to the Visual meta.
-    /** @var \Drupal\emr\Entity\EntityMetaRelationInterface $entity_meta_relation */
+    /** @var EntityMetaRelationInterface $entity_meta_relation */
     $entity_meta_relation = array_shift($entity_meta_relations);
     $this->assertEquals(1, $entity_meta_relation->getRevisionId());
     $this->assertEquals(1, $entity_meta_relation->get('emr_meta_revision')->target_id);
@@ @@
    * Tests that entity metas can be attached to content entities.
    */
   public function testContentEntityAttach() {
-    /** @var \Drupal\node\NodeInterface $node */
+    /** @var NodeInterface $node */
     $node = $this->nodeStorage->create([
       'type' => 'entity_meta_multi_example_ct',
       'title' => 'Second node',
@@ @@
     $this->assertTrue($entity_meta_speed->isNew());
     $entity_meta_speed->getWrapper()->setGear(1);

-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+    /** @var EntityMetaInterface $entity_meta */
     $entity_meta_audio = $this->getEntityMetaList($node)->getEntityMeta('audio');
     $entity_meta_audio->getWrapper()->setVolume('low');

@@ @@
    * Tests that entity metas can be detached from content entities.
    */
   public function testContentEntityDetach() {
-    /** @var \Drupal\node\NodeInterface $node */
+    /** @var NodeInterface $node */
     $node = $this->nodeStorage->create([
       'type' => 'entity_meta_multi_example_ct',
       'title' => 'Second node',
@@ @@
    * Test setting entity metas using the field API setter.
    */
   public function testContentEntitySet() {
-    /** @var \Drupal\node\NodeInterface $first_node */
+    /** @var NodeInterface $first_node */
     $node = $this->nodeStorage->create([
       'type' => 'entity_meta_multi_example_ct',
       'title' => 'Node test',
@@ @@
       'bundle' => 'speed',
       'field_gear' => '3',
     ]);
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+    /** @var EntityMetaInterface $entity_meta */
     $entity_meta_audio = $this->entityMetaStorage->create([
       'bundle' => 'audio',
       'field_volume' => 'low',
@@ @@
       'bundle' => 'speed',
       'field_gear' => '3',
     ])->save();
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+    /** @var EntityMetaInterface $entity_meta */
     $this->entityMetaStorage->create([
       'bundle' => 'audio',
       'field_volume' => 'low',
@@ @@
    * Tests the entity meta default marking with a host.
    */
   public function testEntityMetaDefaultRevisionsWithHost(): void {
-    /** @var \Drupal\node\NodeInterface $node */
+    /** @var NodeInterface $node */
     $node = $this->nodeStorage->create([
       'type' => 'entity_meta_example_ct',
       'title' => 'Second node',
@@ @@
    * Tests the computed default revision field.
    */
   public function testDefaultRevisionField(): void {
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+    /** @var EntityMetaInterface $entity_meta */
     $entity_meta = $this->entityMetaStorage->create([
       'bundle' => 'speed',
       'field_gear' => '3',
@@ @@
   /**
    * Helper method to retrieve the entity meta list field value from a Node.
    *
-   * @param \Drupal\node\NodeInterface $node
+   * @param NodeInterface $node
    *   The node.
    *
-   * @return \Drupal\emr\Field\EntityMetaItemListInterface
+   * @return EntityMetaItemListInterface
    *   The computed list.
    */
   protected function getEntityMetaList(NodeInterface $node): EntityMetaItemListInterface {
@@ @@
   /**
    * Asserts a given entity meta's default revision ID.
    *
-   * @param \Drupal\emr\Entity\EntityMetaInterface $entity_meta
+   * @param EntityMetaInterface $entity_meta
    *   The entity meta.
    * @param int|strin $revision_id
    *   The expected revision ID.
    ----------- end diff -----------

Applied rules:
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * AssertEqualsParameterToSpecificMethodsTypeRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * AddReturnTypeDeclarationRector
 * ChangeMethodVisibilityRector


2) modules/contrib/entity_meta_relation/tests/src/Kernel/EntityMetaRelationRevisionTest.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\Tests\emr\Kernel;

+use Drupal\emr\EntityMetaStorageInterface;
+use Drupal\emr\EntityMetaRelationStorageInterface;
+use Drupal\node\NodeStorageInterface;
+use Drupal\node\NodeInterface;
+use Drupal\emr\Entity\EntityMetaInterface;
 use Drupal\KernelTests\KernelTestBase;

 /**
@@ @@
   /**
    * The entity meta storage.
    *
-   * @var \Drupal\emr\EntityMetaStorageInterface
+   * @var EntityMetaStorageInterface
    */
   protected $entityMetaStorage;

@@ @@
   /**
    * The entity meta relation storage.
    *
-   * @var \Drupal\emr\EntityMetaRelationStorageInterface
+   * @var EntityMetaRelationStorageInterface
    */
   protected $entityMetaRelationStorage;

@@ @@
   /**
    * The node storage.
    *
-   * @var \Drupal\node\NodeStorageInterface
+   * @var NodeStorageInterface
    */
   protected $nodeStorage;

@@ @@
    */
   public function testContentEntityRevisionsRevert() {
     // Revert first revision.
-    /** @var \Drupal\node\NodeInterface $node_first_revision */
+    /** @var NodeInterface $node_first_revision */
     $node_first_revision = $this->nodeStorage->loadRevision(1);
     $node_first_revision->setNewRevision(TRUE);
     $node_first_revision->save();
@@ @@
    * list.
    */
   public function testContentEntityRevisionStatus(): void {
-    /** @var \Drupal\node\NodeInterface $node */
+    /** @var NodeInterface $node */
     $node = $this->nodeStorage->create([
       'type' => 'entity_meta_multi_example_ct',
       'title' => 'Node test',
@@ @@

     $this->nodeStorage->resetCache();
     $node = $this->nodeStorage->load($node->id());
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+    /** @var EntityMetaInterface $entity_meta */
     $entity_meta = $node->get('emr_entity_metas')->getEntityMeta('visual');
     $this->assertTrue($entity_meta->isEnabled());

@@ @@
     // Now the meta should be disabled.
     $this->nodeStorage->resetCache();
     $node = $this->nodeStorage->load($node->id());
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+    /** @var EntityMetaInterface $entity_meta */
     $entity_meta = $node->get('emr_entity_metas')->getEntityMeta('visual');
     $this->assertFalse($entity_meta->isEnabled());
   }
@@ @@
    * Create a node with changes done through three revisions.
    */
   protected function createNodeWithFourRevisions() {
-    /** @var \Drupal\node\NodeInterface $node */
+    /** @var NodeInterface $node */
     $node = $this->nodeStorage->create([
       'type' => 'entity_meta_multi_example_ct',
       'title' => 'Node test',
@@ @@

     // Third revision - Change visual and speed.
     $this->nodeStorage->resetCache();
-    /** @var \Drupal\node\NodeInterface $node */
+    /** @var NodeInterface $node */
     $node = $this->nodeStorage->load(1);
     $entity_meta_visual = $node->get('emr_entity_metas')->getEntityMeta('visual');
     $entity_meta_speed = $node->get('emr_entity_metas')->getEntityMeta('speed');
@@ @@
     $node->save();

     // Fourth revision - Change visual an publish back the node.
-    /** @var \Drupal\node\NodeInterface $node */
+    /** @var NodeInterface $node */
     $node = $this->nodeStorage->load(1);
     $entity_meta_visual = $node->get('emr_entity_metas')->getEntityMeta('visual');
     $entity_meta_visual->set('field_color', 'red');
@@ @@
    *   The Node revision ID.
    */
   protected function assertEntityMetaRevisionValues(int $revision): void {
-    /** @var \Drupal\node\NodeInterface $node */
+    /** @var NodeInterface $node */
     $node = $this->nodeStorage->loadRevision($revision);

     switch ($revision) {
    ----------- end diff -----------

Applied rules:
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * AssertEqualsParameterToSpecificMethodsTypeRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * AddReturnTypeDeclarationRector
 * ChangeMethodVisibilityRector


3) modules/contrib/entity_meta_relation/tests/src/Kernel/EntityMetaRelationAttachByDefaultTest.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\Tests\emr\Kernel;

+use Drupal\emr\EntityMetaStorageInterface;
+use Drupal\emr\EntityMetaRelationStorageInterface;
+use Drupal\node\NodeStorageInterface;
+use Drupal\emr\Entity\EntityMetaInterface;
 use Drupal\emr\Field\EntityMetaItemListInterface;
 use Drupal\KernelTests\KernelTestBase;
 use Drupal\node\NodeInterface;
@@ @@
   /**
    * The entity meta storage.
    *
-   * @var \Drupal\emr\EntityMetaStorageInterface
+   * @var EntityMetaStorageInterface
    */
   protected $entityMetaStorage;

@@ @@
   /**
    * The entity meta relation storage.
    *
-   * @var \Drupal\emr\EntityMetaRelationStorageInterface
+   * @var EntityMetaRelationStorageInterface
    */
   protected $entityMetaRelationStorage;

@@ @@
   /**
    * The node storage.
    *
-   * @var \Drupal\node\NodeStorageInterface
+   * @var NodeStorageInterface
    */
   protected $nodeStorage;

@@ @@

     // We create a first node, we don't use for anything to ensure we don't
     // have coincidental matching IDs between nodes and entity metas.
-    /** @var \Drupal\node\NodeInterface $first_node */
+    /** @var NodeInterface $first_node */
     $first_node = $this->nodeStorage->create([
       'type' => 'entity_meta_example_ct',
       'title' => 'First node',
@@ @@
    * values when needed.
    */
   public function testCreateEntityMetaWithDefaultValues() {
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+    /** @var EntityMetaInterface $entity_meta */
     $entity_meta = $this->entityMetaStorage->create([
       'bundle' => 'force',
     ]);
@@ @@
     // Assert that force EntityMeta has default values.
     $this->assertEquals('weak', $entity_meta->getWrapper()->getGravity());

-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+    /** @var EntityMetaInterface $entity_meta */
     $entity_meta = $this->entityMetaStorage->create([
       'bundle' => 'audio',
     ]);
@@ @@
    * Tests that entity metas can be created with default values.
    */
   public function testApiWithDefaultValues() {
-    /** @var \Drupal\node\NodeInterface $node */
+    /** @var NodeInterface $node */
     $node = $this->nodeStorage->create([
       'type' => 'entity_meta_example_ct',
       'title' => 'Second node',
@@ @@
    * Tests that the host entity can skip the presetting of defaults in the meta.
    */
   public function testApiWithSkippingDefaultValues() {
-    /** @var \Drupal\node\NodeInterface $node */
+    /** @var NodeInterface $node */
     $node = $this->nodeStorage->create([
       'type' => 'entity_meta_example_ct',
       'title' => 'Second node',
@@ @@
   /**
    * Helper method to retrieve the entity meta list field value from a Node.
    *
-   * @param \Drupal\node\NodeInterface $node
+   * @param NodeInterface $node
    *   The node.
    *
-   * @return \Drupal\emr\Field\EntityMetaItemListInterface
+   * @return EntityMetaItemListInterface
    *   The computed list.
    */
   protected function getEntityMetaList(NodeInterface $node): EntityMetaItemListInterface {
    ----------- end diff -----------

Applied rules:
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * AssertEqualsParameterToSpecificMethodsTypeRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * AddReturnTypeDeclarationRector
 * ChangeMethodVisibilityRector


4) modules/contrib/entity_meta_relation/tests/src/Functional/EntityMetaRelationContentFormTest.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\Tests\entity_meta_relation\Functional;

+use Drupal\Core\Session\AccountInterface;
+use Drupal\emr\EntityMetaStorageInterface;
+use Drupal\emr\EntityMetaRelationStorageInterface;
+use Drupal\node\NodeStorageInterface;
 use Drupal\Core\Entity\EntityInterface;
 use Drupal\language\Entity\ConfigurableLanguage;
 use Drupal\Tests\BrowserTestBase;
@@ @@
   /**
    * Admin user.
    *
-   * @var \Drupal\Core\Session\AccountInterface
+   * @var AccountInterface
    */
   protected $adminUser;

@@ @@
    * Tests content editing in entities using a single entity meta.
    */
   public function testContentWithSingleEntityMetaEditing(): void {
-    /** @var \Drupal\emr\EntityMetaStorageInterface $entity_meta_storage */
+    /** @var EntityMetaStorageInterface $entity_meta_storage */
     $entity_meta_storage = \Drupal::service('entity_type.manager')->getStorage('entity_meta');
-    /** @var \Drupal\emr\EntityMetaRelationStorageInterface $entity_meta_relation_storage */
+    /** @var EntityMetaRelationStorageInterface $entity_meta_relation_storage */
     $entity_meta_relation_storage = \Drupal::service('entity_type.manager')->getStorage('entity_meta_relation');

     // Create a new content entity but don't specify any meta value.
@@ @@
    * Tests that we can unset an entity meta relation in the form.
    */
   public function testRemoveMetaRelation(): void {
-    /** @var \Drupal\emr\EntityMetaStorageInterface $entity_meta_storage */
+    /** @var EntityMetaStorageInterface $entity_meta_storage */
     $entity_meta_storage = \Drupal::service('entity_type.manager')->getStorage('entity_meta');
-    /** @var \Drupal\emr\EntityMetaRelationStorageInterface $entity_meta_relation_storage */
+    /** @var EntityMetaRelationStorageInterface $entity_meta_relation_storage */
     $entity_meta_relation_storage = \Drupal::service('entity_type.manager')->getStorage('entity_meta_relation');

     // Create a new content entity with a meta value.
@@ @@
    * Tests content editing in entities using multiple entity metas.
    */
   public function testContentWithMultiEntityMetaEditing(): void {
-    /** @var \Drupal\emr\EntityMetaStorageInterface $entity_meta_storage */
+    /** @var EntityMetaStorageInterface $entity_meta_storage */
     $entity_meta_storage = \Drupal::service('entity_type.manager')->getStorage('entity_meta');
-    /** @var \Drupal\emr\EntityMetaRelationStorageInterface $entity_meta_relation_storage */
+    /** @var EntityMetaRelationStorageInterface $entity_meta_relation_storage */
     $entity_meta_relation_storage = \Drupal::service('entity_type.manager')->getStorage('entity_meta_relation');
-    /** @var \Drupal\node\NodeStorageInterface $node_storage */
+    /** @var NodeStorageInterface $node_storage */
     $node_storage = \Drupal::service('entity_type.manager')->getStorage('node');

     // Create a new content entity but don't specify any meta value.
@@ @@
    * @param string $label
    *   The label of the entity to load.
    *
-   * @return \Drupal\Core\Entity\EntityInterface
+   * @return EntityInterface
    *   The entity.
    */
   protected function getEntityByLabel($type, $label): EntityInterface {
    ----------- end diff -----------

Applied rules:
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * AssertEqualsParameterToSpecificMethodsTypeRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * AddReturnTypeDeclarationRector
 * ChangeMethodVisibilityRector


5) modules/contrib/entity_meta_relation/src/Plugin/EntityMetaRelationPluginManager.php:16

    ---------- begin diff ----------
@@ @@
    * @param \Traversable $namespaces
    *   An object that implements \Traversable which contains the root paths
    *   keyed by the corresponding namespace to look for plugin implementations.
-   * @param \Drupal\Core\Cache\CacheBackendInterface $cache_backend
+   * @param CacheBackendInterface $cache_backend
    *   Cache backend instance to use.
-   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
+   * @param ModuleHandlerInterface $module_handler
    *   The module handler to invoke the alter hook with.
    */
   public function __construct(\Traversable $namespaces, CacheBackendInterface $cache_backend, ModuleHandlerInterface $module_handler) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


6) modules/contrib/entity_meta_relation/src/Plugin/EntityMetaRelationPluginInterface.php:15

    ---------- begin diff ----------
@@ @@
   /**
    * Checks if the plugin is applicable to the passed content entity.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity
+   * @param ContentEntityInterface $entity
    *   The content entity.
    *
    * @return bool
@@ @@
   /**
    * Fill entity meta with default values.
    *
-   * @param \Drupal\emr\Entity\EntityMetaInterface $entity_meta
+   * @param EntityMetaInterface $entity_meta
    *   The entity meta.
    */
   public function fillDefaultEntityMetaValues(EntityMetaInterface $entity_meta): void;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


7) modules/contrib/entity_meta_relation/src/Plugin/EntityMetaRelationPluginBase.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\emr\Plugin;

+use Drupal\emr\EntityMetaStorageInterface;
+use Drupal\Core\Field\FieldConfigInterface;
+use Drupal\Core\Config\Entity\ConfigEntityInterface;
 use Drupal\Component\Plugin\PluginBase;
 use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\Core\Entity\EntityFieldManagerInterface;
@@ @@
   /**
    * The entity field manager.
    *
-   * @var \Drupal\Core\Entity\EntityFieldManagerInterface
+   * @var EntityFieldManagerInterface
    */
   protected $entityFieldManager;

@@ @@
   /**
    * The entity type manager.
    *
-   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   * @var EntityTypeManagerInterface
    */
   protected $entityTypeManager;

@@ @@
   /**
    * The entity meta storage.
    *
-   * @var \Drupal\emr\EntityMetaStorageInterface
+   * @var EntityMetaStorageInterface
    */
   protected $entityMetaStorage;

@@ @@
       return FALSE;
     }

-    /** @var \Drupal\Core\Field\FieldConfigInterface $content_field_definition */
+    /** @var FieldConfigInterface $content_field_definition */
     $meta_field_definition = $fields[$entity_meta_relation_meta_field];
     $target_meta_bundles = $meta_field_definition->getSetting('handler_settings')['target_bundles'] ?? [];
     // If the associated entity meta bundle used by the plugin is not available
@@ @@
       return FALSE;
     }

-    /** @var \Drupal\Core\Field\FieldConfigInterface $field_definition */
+    /** @var FieldConfigInterface $field_definition */
     $content_field_definition = $fields[$entity_meta_relation_content_field];
     $target_content_bundles = $content_field_definition->getSetting('handler_settings')['target_bundles'];
     // If current content bundle is not available in the relationship,
@@ @@
     // If this entity has bundles, checks that the plugin is applicable to it.
     if (!empty($entity->getEntityType()->getBundleEntityType())) {
       $bundle_storage = $this->entityTypeManager->getStorage($entity->getEntityType()->getBundleEntityType());
-      /** @var \Drupal\Core\Config\Entity\ConfigEntityInterface $bundle */
+      /** @var ConfigEntityInterface $bundle */
       $bundle = $bundle_storage->load($entity->bundle());
       $entity_meta_bundles = $bundle->getThirdPartySetting('emr', 'entity_meta_bundles');
       if (!in_array($this->pluginDefinition['entity_meta_bundle'], $entity_meta_bundles)) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


8) modules/contrib/entity_meta_relation/src/Plugin/EntityMetaRelationInlineContentFormPluginBase.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\emr\Plugin;

+use Drupal\emr\Entity\EntityMetaInterface;
 use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\Core\Form\FormStateInterface;
 use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
@@ @@
    * {@inheritdoc}
    */
   public function submit(array $form, FormStateInterface $form_state): void {
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $host_entity */
+    /** @var ContentEntityInterface $host_entity */
     $host_entity = $form_state->getFormObject()->getEntity();

     $key = $this->getFormKey();
@@ @@
     $inline_form_handler = $this->entityTypeManager->getHandler($entity_form['#entity_type'], 'inline_form');
     $inline_form_handler->entityFormSubmit($entity_form, $form_state);

-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity */
+    /** @var EntityMetaInterface $entity */
     $entity = $entity_form['#entity'];
     $host_entity->get('emr_entity_metas')->attach($entity);
   }
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


9) modules/contrib/entity_meta_relation/src/Plugin/EntityMetaRelationContentFormPluginInterface.php:24

    ---------- begin diff ----------
@@ @@
    *
    * @param array $form
    *   The form.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The form state.
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity
+   * @param ContentEntityInterface $entity
    *   The entity.
    *
    * @return array
@@ @@
    *
    * @param array $form
    *   The form.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The form state.
    */
   public function validate(array $form, FormStateInterface $form_state): void;
@@ @@
    *
    * @param array $form
    *   The form.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The form state.
    */
   public function submit(array $form, FormStateInterface $form_state): void;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


10) modules/contrib/entity_meta_relation/src/Plugin/EntityMetaRelationContentFormPluginBase.php:30

    ---------- begin diff ----------
@@ @@
    *
    * @param array $form
    *   The form.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The form state.
    * @param string $key
    *   The key to use for the container.
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


11) modules/contrib/entity_meta_relation/src/Form/EntityMetaRelationForm.php:20

    ---------- begin diff ----------
@@ @@
     $link = $entity->toLink($this->t('View'))->toRenderable();

     $message_arguments = ['%label' => $this->entity->label()];
-    $logger_arguments = $message_arguments + ['link' => render($link)];
+    $logger_arguments = $message_arguments + ['link' => \Drupal::service('renderer')->render($link)];

     if ($result === SAVED_NEW) {
       $this->messenger()->addStatus($this->t('New entity meta relation %label has been created.', $message_arguments));
    ----------- end diff -----------

Applied rules:
 * RenderRector
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


12) modules/contrib/entity_meta_relation/src/Form/EntityMetaForm.php:20

    ---------- begin diff ----------
@@ @@
     $link = $entity->toLink($this->t('View'))->toRenderable();

     $message_arguments = ['%label' => $this->entity->label()];
-    $logger_arguments = $message_arguments + ['link' => render($link)];
+    $logger_arguments = $message_arguments + ['link' => \Drupal::service('renderer')->render($link)];

     if ($result === SAVED_NEW) {
       $this->messenger()->addStatus($this->t('New entity meta %label has been created.', $message_arguments));
    ----------- end diff -----------

Applied rules:
 * RenderRector
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


13) modules/contrib/entity_meta_relation/src/Field/EntityMetaItemListInterface.php:16

    ---------- begin diff ----------
@@ @@
    * EntityMeta entities are added to the existing list or replaced if they are
    * already there.
    *
-   * @param \Drupal\emr\Entity\EntityMetaInterface $entity
+   * @param EntityMetaInterface $entity
    *   The entity meta.
    */
   public function attach(EntityMetaInterface $entity): void;
@@ @@
    * they can either be marked to have their EntityMetaRelation revision skipped
    * or deleted.
    *
-   * @param \Drupal\emr\Entity\EntityMetaInterface $entity
+   * @param EntityMetaInterface $entity
    *   The entity meta.
    *
    * @see self::entitiesToSkipRelations
@@ @@
    * @param string $bundle
    *   The EntityMeta type.
    *
-   * @return \Drupal\emr\Entity\EntityMetaInterface
+   * @return EntityMetaInterface
    *   The entity meta or NULL if none found.
    */
   public function getEntityMeta(string $bundle): ?EntityMetaInterface;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


14) modules/contrib/entity_meta_relation/src/Field/ComputedEntityMetasItemList.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\emr\Field;

+use Drupal\emr\EntityMetaStorageInterface;
 use Drupal\Core\Field\FieldItemList;
 use Drupal\Core\TypedData\ComputedItemListTrait;
 use Drupal\emr\Entity\EntityMetaInterface;
@@ @@
    * EntityMeta. However, the previous revision will still link to the
    * EntityMeta via existing EntityMetaRelation revisions.
    *
-   * @var \Drupal\emr\Entity\EntityMetaInterface[]
+   * @var EntityMetaInterface[]
    */
   protected $entitiesToSkipRelations = [];

@@ @@
    * current revision. However, the previous revisions will still link to the
    * EntityMeta via existing EntityMetaRelation revisions.
    *
-   * @var \Drupal\emr\Entity\EntityMetaInterface[]
+   * @var EntityMetaInterface[]
    */
   protected $entitiesToDeleteRelations = [];

@@ @@
       return;
     }

-    /** @var \Drupal\emr\EntityMetaStorageInterface $entity_meta_storage */
+    /** @var EntityMetaStorageInterface $entity_meta_storage */
     $entity_meta_storage = \Drupal::entityTypeManager()->getStorage('entity_meta');
     $entity_metas = $entity_meta_storage->getRelatedEntities($entity);

-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+    /** @var EntityMetaInterface $entity_meta */
     foreach ($entity_metas as $entity_meta_id => $entity_meta) {
       $delta = count($this->list);
       $this->list[$delta] = $this->createItem($delta, $entity_meta);
@@ @@
     $values = $this->list;
     $uuid = $entity->uuid();

-    /** @var \Drupal\emr\Entity\EntityMetaInterface $item */
+    /** @var EntityMetaInterface $item */
     foreach ($values as $delta => $item) {
       if ($uuid === $item->entity->uuid()) {
         // If we already have it in the list, replace it and we are done.
@@ @@
    * EntityMeta entities are only attached in case they have changes because we
    * don't want them updated if there are no changes.
    *
-   * @param \Drupal\emr\Entity\EntityMetaInterface $entity
+   * @param EntityMetaInterface $entity
    *   The entity meta entity.
    *
    * @return bool
@@ @@
    *   Whether it should attach or not.
    */
   protected function shouldAttach(EntityMetaInterface $entity): bool {
-    /** @var \Drupal\emr\EntityMetaStorageInterface $entity_meta_storage */
+    /** @var EntityMetaStorageInterface $entity_meta_storage */
     $entity_meta_storage = \Drupal::entityTypeManager()->getStorage('entity_meta');

     $change_fields = $entity_meta_storage->getChangeFields($entity);
@@ @@
     }

     if (empty($entity_meta)) {
-      /** @var \Drupal\emr\EntityMetaStorageInterface $entity_meta_storage */
+      /** @var EntityMetaStorageInterface $entity_meta_storage */
       $entity_meta_storage = $entity_type_manager = \Drupal::entityTypeManager()->getStorage('entity_meta');
       $entity_meta = $entity_meta_storage->create([
         'bundle' => $bundle,
@@ @@
     // Detach all the values that have not found themselves in the new list.
     $content_entity = $this->getEntity();
     foreach ($to_detach as $item) {
-      /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+      /** @var EntityMetaInterface $entity_meta */
       $entity_meta = $item->entity;

       if ($content_entity->isNewRevision()) {
@@ @@
     // Keep track of the new revision in case the loaded one was updated.
     $new_revision = NULL;
     $reverting = FALSE;
-    /** @var \Drupal\emr\EntityMetaStorageInterface $entity_meta_storage */
+    /** @var EntityMetaStorageInterface $entity_meta_storage */
     $entity_meta_storage = \Drupal::entityTypeManager()->getStorage('entity_meta');

     if (empty($this->list) && empty($this->entitiesToSkipRelations) && empty($this->entitiesToDeleteRelations)) {
@@ @@
         continue;
       }

-      /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+      /** @var EntityMetaInterface $entity_meta */
       $entity_meta = $item->entity;
       if (isset($default_entity_metas[$entity_meta->bundle()])) {
         unset($default_entity_metas[$entity_meta->bundle()]);
@@ @@
    *
    * Marks them also correctly on what should happen with their relations.
    *
-   * @param \Drupal\emr\Entity\EntityMetaInterface $entity_meta
+   * @param EntityMetaInterface $entity_meta
    *   The entity meta.
    *
    * @return bool
@@ @@
   /**
    * Looks in the list for an EntityMeta and returns its delta.
    *
-   * @param \Drupal\emr\Entity\EntityMetaInterface $entity_meta
+   * @param EntityMetaInterface $entity_meta
    *   The entity meta entity.
    *
    * @return int|null
@@ @@
    */
   public function delete() {
     $entity = $this->getEntity();
-    /** @var \Drupal\emr\EntityMetaStorageInterface $storage */
+    /** @var EntityMetaStorageInterface $storage */
     $storage = \Drupal::entityTypeManager()->getStorage('entity_meta');
     $storage->deleteAllRelatedMetaEntities($entity);
   }
@@ @@
    */
   public function deleteRevision() {
     parent::deleteRevision();
-    /** @var \Drupal\emr\EntityMetaStorageInterface $storage */
+    /** @var EntityMetaStorageInterface $storage */
     $storage = \Drupal::entityTypeManager()->getStorage('entity_meta');
     $storage->deleteAllRelatedEntityMetaRelationRevisions($this->getEntity());
   }
@@ @@
    * @param mixed $item
    *   The field item.
    *
-   * @return \Drupal\emr\Entity\EntityMetaInterface|null
+   * @return EntityMetaInterface|null
    *   The EntityMeta or NULL if none can be found.
    */
   protected function getEntityMetaFromFieldItem($item): ?EntityMetaInterface {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


15) modules/contrib/entity_meta_relation/src/EntityMetaWrapperInterface.php:13

    ---------- begin diff ----------
@@ @@
   /**
    * Returns the entity meta.
    *
-   * @return \Drupal\emr\Entity\EntityMetaInterface
+   * @return EntityMetaInterface
    *   The entity meta.
    */
   public function getEntityMeta(): EntityMetaInterface;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


16) modules/contrib/entity_meta_relation/src/EntityMetaWrapperFactoryInterface.php:16

    ---------- begin diff ----------
@@ @@
    * Instantiate a new entity meta wrapper or a more specific class in case it
    * finds a plugin mapping an entity meta wrapper class to this bundle.
    *
-   * @param \Drupal\emr\Entity\EntityMetaInterface $entity_meta
+   * @param EntityMetaInterface $entity_meta
    *   The entity meta.
    *
-   * @return \Drupal\emr\EntityMetaWrapper
+   * @return EntityMetaWrapper
    *   The entity meta wrapper.
    */
   public function create(EntityMetaInterface $entity_meta);
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


17) modules/contrib/entity_meta_relation/src/EntityMetaWrapperFactory.php:14

    ---------- begin diff ----------
@@ @@
   /**
    * The plugin manager.
    *
-   * @var \Drupal\emr\Plugin\EntityMetaRelationPluginManager
+   * @var EntityMetaRelationPluginManager
    */
   protected $pluginManager;

@@ @@
   /**
    * EntityMetaWrapperFactory constructor.
    *
-   * @param \Drupal\emr\Plugin\EntityMetaRelationPluginManager $pluginManager
+   * @param EntityMetaRelationPluginManager $pluginManager
    *   The plugin manager.
    */
   public function __construct(EntityMetaRelationPluginManager $pluginManager) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


18) modules/contrib/entity_meta_relation/src/EntityMetaWrapper.php:13

    ---------- begin diff ----------
@@ @@
   /**
    * The entity meta.
    *
-   * @var \Drupal\emr\Entity\EntityMetaInterface
+   * @var EntityMetaInterface
    */
   protected $entityMeta;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


19) modules/contrib/entity_meta_relation/src/EntityMetaStorageInterface.php:14

    ---------- begin diff ----------
@@ @@
   /**
    * Gets a list of revision IDs for a specific entity meta.
    *
-   * @param \Drupal\emr\Entity\EntityMetaInterface $entity_meta
+   * @param EntityMetaInterface $entity_meta
    *   The entity meta.
    *
    * @return int[]
@@ @@
    *
    * Note that this will return the last revision of the target entities
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity
+   * @param ContentEntityInterface $entity
    *   The entity to look for related entities.
    *
-   * @return \Drupal\Core\Entity\ContentEntityInterface[]
+   * @return ContentEntityInterface[]
    *   The related entities.
    */
   public function getRelatedEntities(ContentEntityInterface $entity): array;
@@ @@
    * We don't need to delete the relation entities because those are deleted
    * in turn when an entity meta is deleted.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $content_entity
+   * @param ContentEntityInterface $content_entity
    *   The content entity.
    *
    * @see emr_entity_delete()
@@ @@
    * These are the revisions that reference the current revision of the passed
    * host entity.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $content_entity
+   * @param ContentEntityInterface $content_entity
    *   The content entity.
    */
   public function deleteAllRelatedEntityMetaRelationRevisions(ContentEntityInterface $content_entity): void;
@@ @@
    * These are only the FieldConfigInterface fields because these are the ones
    * where we store data (since we are using bundles).
    *
-   * @param \Drupal\emr\Entity\EntityMetaInterface $entity
+   * @param EntityMetaInterface $entity
    *   The entity.
    *
    * @return array
@@ @@
    *
    * We make a new revision if there is a change in one of the relevant fields.
    *
-   * @param \Drupal\emr\Entity\EntityMetaInterface $entity
+   * @param EntityMetaInterface $entity
    *   The entity meta entity.
    *
    * @return bool
@@ @@
    * that some defaults need to be set on them whenever the host entity gets
    * created.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity
+   * @param ContentEntityInterface $entity
    *   The host entity for which to determine the default metas.
    *
-   * @return \Drupal\emr\Entity\EntityMetaInterface[]
+   * @return EntityMetaInterface[]
    *   The list of default entity metas.
    */
   public function getDefaultEntityMetas(ContentEntityInterface $entity): array;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


20) modules/contrib/entity_meta_relation/src/EntityMetaStorage.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\emr;

+use Drupal\emr\Plugin\EntityMetaRelationPluginInterface;
+use Drupal\Core\Entity\RevisionableInterface;
+use Drupal\emr\Entity\EntityMetaRelationInterface;
 use Drupal\Core\Cache\CacheBackendInterface;
 use Drupal\Core\Cache\MemoryCache\MemoryCacheInterface;
 use Drupal\Core\Database\Connection;
@@ @@
   /**
    * The entity meta wrapper factory.
    *
-   * @var \Drupal\emr\EntityMetaWrapperFactoryInterface
+   * @var EntityMetaWrapperFactoryInterface
    */
   protected $entityMetaWrapperFactory;

@@ @@
   /**
    * The entity meta relation plugin manager.
    *
-   * @var \Drupal\emr\Plugin\EntityMetaRelationPluginManager
+   * @var EntityMetaRelationPluginManager
    */
   protected $pluginManager;

@@ @@
   /**
    * Constructs a EntityMetaStorage object.
    *
-   * @param \Drupal\Core\Entity\EntityTypeInterface $entity_type
+   * @param EntityTypeInterface $entity_type
    *   The entity type definition.
-   * @param \Drupal\Core\Database\Connection $database
+   * @param Connection $database
    *   The database connection to be used.
-   * @param \Drupal\Core\Entity\EntityFieldManagerInterface $entity_field_manager
+   * @param EntityFieldManagerInterface $entity_field_manager
    *   The entity field manager.
-   * @param \Drupal\Core\Cache\CacheBackendInterface $cache
+   * @param CacheBackendInterface $cache
    *   The cache backend to be used.
-   * @param \Drupal\Core\Language\LanguageManagerInterface $language_manager
+   * @param LanguageManagerInterface $language_manager
    *   The language manager.
-   * @param \Drupal\Core\Cache\MemoryCache\MemoryCacheInterface|null $memory_cache
+   * @param MemoryCacheInterface|null $memory_cache
    *   The memory cache backend to be used.
-   * @param \Drupal\Core\Entity\EntityTypeBundleInfoInterface $entity_type_bundle_info
+   * @param EntityTypeBundleInfoInterface $entity_type_bundle_info
    *   The entity type bundle info.
-   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   * @param EntityTypeManagerInterface $entity_type_manager
    *   The entity type manager.
-   * @param \Drupal\emr\EntityMetaWrapperFactoryInterface $entity_meta_wrapper_factory
+   * @param EntityMetaWrapperFactoryInterface $entity_meta_wrapper_factory
    *   The entity meta wrapper factory.
-   * @param \Drupal\emr\Plugin\EntityMetaRelationPluginManager $pluginManager
+   * @param EntityMetaRelationPluginManager $pluginManager
    *   The entity meta relation plugin manager.
    *
    * @SuppressWarnings(PHPMD.ExcessiveParameterList)
@@ @@
    */
   public function create(array $values = []) {
     // Set the wrapper on the EntityMeta.
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity */
+    /** @var EntityMetaInterface $entity */
     $entity = parent::create($values);
     $entity->setWrapper($this->entityMetaWrapperFactory->create($entity));

     $default_definition = $this->pluginManager->getDefaultDefinitionForBundle($entity->bundle());
     if ($default_definition) {
-      /** @var \Drupal\emr\Plugin\EntityMetaRelationPluginInterface $plugin */
+      /** @var EntityMetaRelationPluginInterface $plugin */
       $plugin = $this->pluginManager->createInstance($default_definition['id']);
       $plugin->fillDefaultEntityMetaValues($entity);
     }
@@ @@
    */
   protected function postLoad(array &$entities) {
     parent::postLoad($entities);
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity */
+    /** @var EntityMetaInterface $entity */
     foreach ($entities as &$entity) {
       // Set the wrapper on the EntityMeta.
       $entity->setWrapper($this->entityMetaWrapperFactory->create($entity));
@@ @@
    * {@inheritdoc}
    */
   public function save(EntityInterface $entity) {
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity */
+    /** @var EntityMetaInterface $entity */
     if ($this->shouldMakeRevision($entity)) {
       $entity->setNewRevision(TRUE);
     }
@@ @@
    * @SuppressWarnings(PHPMD.NPathComplexity)
    */
   public function doPostSave(EntityInterface $entity, $update) {
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity */
+    /** @var EntityMetaInterface $entity */
     parent::doPostSave($entity, $update);

     // Create or updates the entity meta relations for a given entity.
@@ @@
     // associated entity meta relation entities. This is because once an entity
     // meta is deleted for any reason, there is no more relation that needs to
     // existing between it and any content entity.
-    /** @var \Drupal\emr\EntityMetaRelationStorageInterface $entity_meta_relation_storage */
+    /** @var EntityMetaRelationStorageInterface $entity_meta_relation_storage */
     $entity_meta_relation_storage = $this->entityTypeManager->getStorage('entity_meta_relation');
     $entity_meta_relation_fields = [];
     // Determine the field names that reference the entity metas.
@@ @@
    * allow the deletion.
    */
   public function deleteRevision($revision_id) {
-    /** @var \Drupal\Core\Entity\RevisionableInterface $revision */
+    /** @var RevisionableInterface $revision */
     $revision = $this->loadRevision($revision_id);
     if (!$revision instanceof EntityMetaInterface) {
       // It's possible that by the time this revision delete is requested, the
@@ @@
     // to perform the deletion.
     array_pop($revision_ids);
     $revision_id_to_default = end($revision_ids);
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $revision_to_default */
+    /** @var EntityMetaInterface $revision_to_default */
     $revision_to_default = $this->loadRevision($revision_id_to_default);
     $revision_to_default->isDefaultRevision(TRUE);
     $revision_to_default->setNewRevision(FALSE);
@@ @@
     $entity_meta_relation_content_field = $entity_type->get('entity_meta_relation_content_field');
     $entity_meta_relation_meta_field = $entity_type->get('entity_meta_relation_meta_field');

-    /** @var \Drupal\emr\EntityMetaRelationStorageInterface $entity_meta_relation_storage */
+    /** @var EntityMetaRelationStorageInterface $entity_meta_relation_storage */
     $entity_meta_relation_storage = $this->entityTypeManager->getStorage('entity_meta_relation');
     $ids = $entity_meta_relation_storage->getQuery()
       ->condition($entity_meta_relation_content_field . '.target_id', $content_entity->id())
@@ @@
       return;
     }

-    /** @var \Drupal\emr\Entity\EntityMetaRelationInterface[] $entity_meta_relations */
+    /** @var EntityMetaRelationInterface[] $entity_meta_relations */
     $entity_meta_relations = $entity_meta_relation_storage->loadMultiple($ids);
     foreach ($entity_meta_relations as $relation) {
       $entity = $relation->get($entity_meta_relation_meta_field)->entity;
@@ @@

     // Find all the revisions of EntityMetaRelation that point to the current
     // revision of this entity.
-    /** @var \Drupal\emr\EntityMetaRelationStorageInterface $entity_meta_relation_storage */
+    /** @var EntityMetaRelationStorageInterface $entity_meta_relation_storage */
     $entity_meta_relation_storage = $this->entityTypeManager->getStorage('entity_meta_relation');
     $ids = $entity_meta_relation_storage->getQuery()
       ->condition($entity_meta_relation_content_field . '.target_revision_id', $content_entity->getRevisionId())
@@ @@
     }

     // Load all the relation revisions that point to the passed entity.
-    /** @var \Drupal\emr\EntityMetaRelationStorageInterface $entity_meta_relation_storage */
+    /** @var EntityMetaRelationStorageInterface $entity_meta_relation_storage */
     $entity_meta_relation_storage = $this->entityTypeManager->getStorage('entity_meta_relation');
     $ids = $entity_meta_relation_storage->getQuery()
       ->condition($relation_field_name . '.' . $target_field, $target_id)
@@ @@
       return [];
     }

-    /** @var \Drupal\emr\Entity\EntityMetaRelationInterface[] $entity_meta_relations */
+    /** @var EntityMetaRelationInterface[] $entity_meta_relations */
     $entity_meta_relation_revisions = $entity_meta_relation_storage->loadMultipleRevisions(array_keys($ids));

     $related_entities = $related_entities_revisions = [];

-    /** @var \Drupal\emr\Entity\EntityMetaRelationInterface $relation */
+    /** @var EntityMetaRelationInterface $relation */
     foreach ($entity_meta_relation_revisions as $relation) {
       // Find the correct field to get the reverse relation.
       if ($entity instanceof EntityMetaInterface) {
@@ @@
       // In case there are revisions, load the latest revision to compare
       // against.
       $original_id = $this->getLatestRevisionId($entity->id());
-      /** @var \Drupal\Core\Entity\ContentEntityInterface $original */
+      /** @var ContentEntityInterface $original */
       $original = $this->loadRevision($original_id);
     }

@@ @@
         continue;
       }

-      /** @var \Drupal\emr\Plugin\EntityMetaRelationPluginInterface $plugin */
+      /** @var EntityMetaRelationPluginInterface $plugin */
       $plugin = $this->pluginManager->createInstance($id);
       if ($plugin->applies($entity)) {
         $default_metas[$definition['entity_meta_bundle']] = $this->create([
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


21) modules/contrib/entity_meta_relation/src/EntityMetaRelationStorageInterface.php:30

    ---------- begin diff ----------
@@ @@
   /**
    * Gets a list of revision IDs for a specific entity meta relation.
    *
-   * @param \Drupal\emr\Entity\EntityMetaRelationInterface $entity_meta_relation
+   * @param EntityMetaRelationInterface $entity_meta_relation
    *   The entity meta relation.
    *
    * @return int[]
@@ @@
    * This is the name of the field on a given entity meta relation entity that
    * points either to the entity meta or to the content entity.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity
+   * @param ContentEntityInterface $entity
    *   The entity.
    * @param string $target
    *   The relation direction: 'content' or 'meta'.
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


22) modules/contrib/entity_meta_relation/src/EntityMetaRelationStorage.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\emr;

+use Drupal\Core\Field\FieldDefinitionInterface;
+use Drupal\Core\Entity\RevisionableInterface;
 use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\Core\Entity\Sql\SqlContentEntityStorage;
 use Drupal\emr\Entity\EntityMetaInterface;
@@ @@
    */
   public function getRelationFieldName(ContentEntityInterface $entity, string $target): ?string {
     $fields = $this->entityFieldManager->getFieldDefinitions($entity->getEntityTypeId(), $entity->bundle());
-    /** @var \Drupal\Core\Field\FieldDefinitionInterface $field */
+    /** @var FieldDefinitionInterface $field */
     foreach ($fields as $field) {
       if ($field->getType() == 'entity_reference_revisions') {
         if ($target === EntityMetaRelationStorageInterface::RELATION_FIELD_TARGET_CONTENT && $field->getSetting('target_type') !== 'entity_meta') {
@@ @@
    * allow the deletion.
    */
   public function deleteRevision($revision_id) {
-    /** @var \Drupal\Core\Entity\RevisionableInterface $revision */
+    /** @var RevisionableInterface $revision */
     $revision = $this->loadRevision($revision_id);
     if (!$revision->isDefaultRevision()) {
       // If it's not the default revision we just defer to the parent to delete
@@ @@
   public function delete(array $entities) {
     parent::delete($entities);

-    /** @var \Drupal\emr\Entity\EntityMetaRelationInterface $relation */
+    /** @var EntityMetaRelationInterface $relation */
     foreach ($entities as $relation) {
       $field_name = $this->getRelationFieldName($relation, EntityMetaRelationStorageInterface::RELATION_FIELD_TARGET_META);
       $target_revision_id = $relation->get($field_name)->target_revision_id;
@@ @@
    * the EntityMeta revision it was pointing to was not left orphaned (no other
    * relations point to it). If it did, we need to delete it.
    *
-   * @param \Drupal\emr\Entity\EntityMetaRelationInterface $revision
+   * @param EntityMetaRelationInterface $revision
    *   The EntityMetaRelation revision ID.
    */
   protected function deleteOrphanEntityMetaRevision(EntityMetaRelationInterface $revision): void {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


23) modules/contrib/entity_meta_relation/src/EntityMetaRelationListBuilder.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\emr;

+use Drupal\emr\Entity\EntityMetaRelationInterface;
 use Drupal\Core\Entity\EntityInterface;
 use Drupal\Core\Entity\EntityListBuilder;
 use Drupal\Core\Datetime\DateFormatterInterface;
@@ @@
   /**
    * The date formatter service.
    *
-   * @var \Drupal\Core\Datetime\DateFormatterInterface
+   * @var DateFormatterInterface
    */
   protected $dateFormatter;

@@ @@
   /**
    * The redirect destination service.
    *
-   * @var \Drupal\Core\Routing\RedirectDestinationInterface
+   * @var RedirectDestinationInterface
    */
   protected $redirectDestination;

@@ @@
   /**
    * Constructs a new EntityMetaRelationListBuilder object.
    *
-   * @param \Drupal\Core\Entity\EntityTypeInterface $entity_type
+   * @param EntityTypeInterface $entity_type
    *   The entity type definition.
-   * @param \Drupal\Core\Entity\EntityStorageInterface $storage
+   * @param EntityStorageInterface $storage
    *   The entity storage class.
-   * @param \Drupal\Core\Datetime\DateFormatterInterface $date_formatter
+   * @param DateFormatterInterface $date_formatter
    *   The date formatter service.
-   * @param \Drupal\Core\Routing\RedirectDestinationInterface $redirect_destination
+   * @param RedirectDestinationInterface $redirect_destination
    *   The redirect destination service.
    */
   public function __construct(EntityTypeInterface $entity_type, EntityStorageInterface $storage, DateFormatterInterface $date_formatter, RedirectDestinationInterface $redirect_destination) {
@@ @@
    * {@inheritdoc}
    */
   public function buildRow(EntityInterface $entity) {
-    /** @var \Drupal\emr\Entity\EntityMetaRelationInterface $entity */
+    /** @var EntityMetaRelationInterface $entity */
     $row['id'] = $entity->toLink()->toString();
     return $row + parent::buildRow($entity);
   }
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


24) modules/contrib/entity_meta_relation/src/EntityMetaRelationInstaller.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\emr;

+use Drupal\Core\Config\Entity\ConfigEntityBundleBase;
+use Drupal\Core\Field\FieldConfigInterface;
 use Drupal\Core\Config\ConfigFactoryInterface;
 use Drupal\Core\Entity\EntityTypeBundleInfoInterface;
 use Drupal\Core\Entity\EntityTypeManagerInterface;
@@ @@
   /**
    * The config factory.
    *
-   * @var \Drupal\Core\Config\ConfigFactoryInterface
+   * @var ConfigFactoryInterface
    */
   protected $configFactory;

@@ @@
   /**
    * The entity type manager.
    *
-   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   * @var EntityTypeManagerInterface
    */
   protected $entityTypeManager;

@@ @@
   /**
    * The entity type bundle info.
    *
-   * @var \Drupal\Core\Entity\EntityTypeBundleInfoInterface
+   * @var EntityTypeBundleInfoInterface
    */
   protected $entityTypeBundleInfo;

@@ @@
   /**
    * EntityMetaRelationInstaller constructor.
    *
-   * @param \Drupal\Core\Config\ConfigFactoryInterface $configFactory
+   * @param ConfigFactoryInterface $configFactory
    *   The config factory.
-   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entityTypeManager
+   * @param EntityTypeManagerInterface $entityTypeManager
    *   The entity type manager.
-   * @param \Drupal\Core\Entity\EntityTypeBundleInfoInterface $entityTypeBundleInfo
+   * @param EntityTypeBundleInfoInterface $entityTypeBundleInfo
    *   The entity type bundle info.
    */
   public function __construct(ConfigFactoryInterface $configFactory, EntityTypeManagerInterface $entityTypeManager, EntityTypeBundleInfoInterface $entityTypeBundleInfo) {
@@ @@
     // Sets correct 3rd party settings.
     $bundle_entity_storage = $this->entityTypeManager->getStorage($definition->getBundleEntityType());
     foreach ($bundles as $bundle_id) {
-      /** @var \Drupal\Core\Config\Entity\ConfigEntityBundleBase $bundle */
+      /** @var ConfigEntityBundleBase $bundle */
       $bundle = $bundle_entity_storage->load($bundle_id);
       $entity_meta_bundles = $bundle->getThirdPartySetting('emr', 'entity_meta_bundles');
       if (empty($entity_meta_bundles) || !in_array($entity_meta_type, $entity_meta_bundles)) {
@@ @@
    *   The list of allowed bundles.
    */
   protected function updateTargetBundlesInField(string $emr_bundle, string $field_name, array $target_bundles): void {
-    /** @var \Drupal\Core\Field\FieldConfigInterface $field_config */
+    /** @var FieldConfigInterface $field_config */
     $field_config = $this->entityTypeManager->getStorage('field_config')->load("entity_meta_relation.{$emr_bundle}.{$field_name}");
     if (!$field_config) {
       throw new FieldException("Field config 'entity_meta_relation.{$emr_bundle}.{$field_name}' not found. Without this field, we cannot properly configure Entity Meta type.");
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


25) modules/contrib/entity_meta_relation/src/EntityMetaListBuilder.php:17

    ---------- begin diff ----------
@@ @@
   /**
    * The date formatter service.
    *
-   * @var \Drupal\Core\Datetime\DateFormatterInterface
+   * @var DateFormatterInterface
    */
   protected $dateFormatter;

@@ @@
   /**
    * The redirect destination service.
    *
-   * @var \Drupal\Core\Routing\RedirectDestinationInterface
+   * @var RedirectDestinationInterface
    */
   protected $redirectDestination;

@@ @@
   /**
    * Constructs a new EntityMetaListBuilder object.
    *
-   * @param \Drupal\Core\Entity\EntityTypeInterface $entity_type
+   * @param EntityTypeInterface $entity_type
    *   The entity type definition.
-   * @param \Drupal\Core\Entity\EntityStorageInterface $storage
+   * @param EntityStorageInterface $storage
    *   The entity storage class.
-   * @param \Drupal\Core\Datetime\DateFormatterInterface $date_formatter
+   * @param DateFormatterInterface $date_formatter
    *   The date formatter service.
-   * @param \Drupal\Core\Routing\RedirectDestinationInterface $redirect_destination
+   * @param RedirectDestinationInterface $redirect_destination
    *   The redirect destination service.
    */
   public function __construct(EntityTypeInterface $entity_type, EntityStorageInterface $storage, DateFormatterInterface $date_formatter, RedirectDestinationInterface $redirect_destination) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


26) modules/contrib/entity_meta_relation/src/Entity/EntityMetaInterface.php:60

    ---------- begin diff ----------
@@ @@
    *
    * The "host" entity is the content entity which relates to this EntityMeta.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity
+   * @param ContentEntityInterface $entity
    *   The content entity.
    *
    * @return \Drupal\emr\Entity\EntityMetaInterface
@@ @@
   /**
    * Gets the "host" entity.
    *
-   * @return \Drupal\Core\Entity\ContentEntityInterface
+   * @return ContentEntityInterface
    *   Returns the host entity if present.
    */
   public function getHostEntity(): ?ContentEntityInterface;
@@ @@
   /**
    * Gets the wrapper for this entity meta.
    *
-   * @return \Drupal\emr\EntityMetaWrapperInterface
+   * @return EntityMetaWrapperInterface
    *   The entity meta wrapper.
    */
   public function getWrapper(): EntityMetaWrapperInterface;
@@ @@
   /**
    * Sets the wrapper for this entity meta.
    *
-   * @param \Drupal\emr\EntityMetaWrapperInterface $entityMetaWrapper
+   * @param EntityMetaWrapperInterface $entityMetaWrapper
    *   The entity meta wrapper.
    */
   public function setWrapper(EntityMetaWrapperInterface $entityMetaWrapper): void;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


27) modules/contrib/entity_meta_relation/src/Entity/EntityMeta.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\emr\Entity;

+use Drupal\emr\EntityMetaWrapper;
 use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\Core\Entity\EntityChangedTrait;
 use Drupal\Core\Entity\EntityStorageInterface;
@@ @@
   /**
    * The entity meta wrapper.
    *
-   * @var \Drupal\emr\EntityMetaWrapper
+   * @var EntityMetaWrapper
    */
   protected $entityMetaWrapper;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


28) modules/contrib/entity_meta_relation/src/ContentFormHandlerInterface.php:19

    ---------- begin diff ----------
@@ @@
    *
    * @param array $form
    *   The form being altered.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The form state.
    *
    * @return array
@@ @@
    *
    * @param array $form
    *   The form.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The form state.
    */
   public function validateFormElements(array &$form, FormStateInterface $form_state): void;
@@ @@
    *
    * @param array $form
    *   The form.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The form state.
    */
   public function submitFormElements(array &$form, FormStateInterface $form_state): void;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


29) modules/contrib/entity_meta_relation/src/ContentFormHandlerBase.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\emr;

+use Drupal\emr\Plugin\EntityMetaRelationPluginInterface;
 use Drupal\Core\DependencyInjection\DependencySerializationTrait;
 use Drupal\Core\Entity\EntityTypeInterface;
 use Drupal\Core\Form\FormStateInterface;
@@ @@
   /**
    * The entity type.
    *
-   * @var \Drupal\Core\Entity\EntityTypeInterface
+   * @var EntityTypeInterface
    */
   protected $entityType;

@@ @@
   /**
    * The plugin manager.
    *
-   * @var \Drupal\emr\Plugin\EntityMetaRelationPluginManager
+   * @var EntityMetaRelationPluginManager
    */
   protected $pluginManager;

@@ @@
   /**
    * Constructs the EntityMetaContentFormHandlerBase.
    *
-   * @param \Drupal\Core\Entity\EntityTypeInterface $entityType
+   * @param EntityTypeInterface $entityType
    *   The entity type.
-   * @param \Drupal\emr\Plugin\EntityMetaRelationPluginManager $pluginManager
+   * @param EntityMetaRelationPluginManager $pluginManager
    *   The entity meta relation plugin manager.
    */
   public function __construct(EntityTypeInterface $entityType, EntityMetaRelationPluginManager $pluginManager) {
@@ @@
         continue;
       }

-      /** @var \Drupal\emr\Plugin\EntityMetaRelationPluginInterface $plugin */
+      /** @var EntityMetaRelationPluginInterface $plugin */
       $plugin = $this->pluginManager->createInstance($id);
       if ($plugin instanceof EntityMetaRelationContentFormPluginInterface && $plugin->applies($entity)) {
         $form = $plugin->build($form, $form_state, $entity);
@@ @@
    *
    * @param array $form
    *   The form.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The form state.
    *
-   * @return \Drupal\emr\Plugin\EntityMetaRelationContentFormPluginInterface[]
+   * @return EntityMetaRelationContentFormPluginInterface[]
    *   The applicable plugins that can be validated and submitted.
    */
   protected function getApplicablePlugins(array &$form, FormStateInterface $form_state): array {
@@ @@
         continue;
       }

-      /** @var \Drupal\emr\Plugin\EntityMetaRelationPluginInterface $plugin */
+      /** @var EntityMetaRelationPluginInterface $plugin */
       $plugin = $this->pluginManager->createInstance($id);
       if ($plugin instanceof EntityMetaRelationContentFormPluginInterface && $plugin->applies($entity)) {
         $applicable[] = $plugin;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


30) modules/contrib/entity_meta_relation/src/Annotation/EntityMetaRelation.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\emr\Annotation;

+use Drupal\Core\Annotation\Translation;
 use Drupal\Component\Annotation\Plugin;

 /**
@@ @@
   /**
    * The human-readable name of the plugin.
    *
-   * @var \Drupal\Core\Annotation\Translation
+   * @var Translation
    *
    * @ingroup plugin_translatable
    */
@@ @@
   /**
    * The description of the plugin.
    *
-   * @var \Drupal\Core\Annotation\Translation
+   * @var Translation
    *
    * @ingroup plugin_translatable
    */
    ----------- end diff -----------

Applied rules:
 * PseudoNamespaceToNamespaceRector


31) modules/contrib/entity_meta_relation/modules/entity_meta_example/modules/entity_meta_speed/src/Plugin/EntityMetaRelation/SpeedConfiguration.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\entity_meta_speed\Plugin\EntityMetaRelation;

+use Drupal\Core\Entity\EntityInterface;
 use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\Core\Form\FormStateInterface;
 use Drupal\Core\StringTranslation\StringTranslationTrait;
@@ @@
   /**
    * Builds the entity meta from the values of the $form_state.
    *
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The form state.
    *
-   * @return \Drupal\Core\Entity\EntityInterface|\Drupal\emr\Entity\EntityMetaInterface|null
+   * @return EntityInterface|EntityMetaInterface|null
    *   The entity meta.
    */
   protected function buildEntity(FormStateInterface $form_state): ?EntityMetaInterface {
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $entity */
+    /** @var ContentEntityInterface $entity */
     $entity = $form_state->getFormObject()->getEntity();
-    /** @var \Drupal\emr\Entity\EntityMetaInterface $entity_meta */
+    /** @var EntityMetaInterface $entity_meta */
     $entity_meta = $entity->get('emr_entity_metas')->getEntityMeta($this->getPluginDefinition()['entity_meta_bundle']);

     $entity_meta->getWrapper()->setGear($form_state->getValue('gear'));
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


32) modules/contrib/entity_meta_relation/modules/entity_meta_example/entity_meta_example.install:6

    ---------- begin diff ----------
@@ @@

 declare(strict_types = 1);

+use Drupal\emr\EntityMetaRelationInstaller;
+
 /**
  * Implements hook_install().
  */
@@ @@
   if ($is_syncing) {
     return;
   }
-  /** @var \Drupal\emr\EntityMetaRelationInstaller $installer */
+  /** @var EntityMetaRelationInstaller $installer */
   $installer = \Drupal::service('emr.installer');
   $installer->installEntityMetaTypeOnContentEntityType('visual', 'node', ['entity_meta_example_ct']);
   $installer->installEntityMetaTypeOnContentEntityType('audio', 'node', ['entity_meta_multi_example_ct']);
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector


33) modules/contrib/entity_meta_relation/modules/emr_node/emr_node.post_update.php:6

    ---------- begin diff ----------
@@ @@

 declare(strict_types = 1);

+use Drupal\Core\Field\FieldConfigInterface;
+
 /**
  * Fix misconfigured handler_settings.
  */
@@ @@
   $entity_type_manager = \Drupal::entityTypeManager();
   $bundles = \Drupal::service('entity_type.bundle.info')->getAllBundleInfo();
   foreach (['emr_meta_revision', 'emr_node_revision'] as $field_name) {
-    /** @var \Drupal\Core\Field\FieldConfigInterface $field_config */
+    /** @var FieldConfigInterface $field_config */
     $field_config = $entity_type_manager->getStorage('field_config')->load('entity_meta_relation.node_meta_relation.' . $field_name);
     if (!$field_config) {
       continue;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector


34) modules/contrib/entity_meta_relation/modules/emr_node/emr_node.module:5

    ---------- begin diff ----------
@@ @@
  */

 declare(strict_types = 1);
+use Drupal\Core\Entity\EntityTypeInterface;

 use Drupal\emr_node\NodeFormHandler;

@@ @@
     return;
   }

-  /** @var \Drupal\Core\Entity\EntityTypeInterface $entity_type */
+  /** @var EntityTypeInterface $entity_type */
   $entity_type = $entity_types['node'];
   if (!$entity_type->hasHandlerClass('emr_content_form')) {
     // Add the entity meta content form handler to the Node entity type.
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector


35) modules/contrib/entity_meta_relation/emr.post_update.php:0

    ---------- begin diff ----------
@@ @@
 <?php

+use Drupal\emr\EntityMetaStorageInterface;
+use Drupal\emr\Entity\EntityMetaInterface;
 /**
  * @file
  * Entity Meta Relation post update file.
@@ @@
 function emr_post_update_00002(&$sandbox) {
   \Drupal::service('plugin.manager.field.field_type')->clearCachedDefinitions();

-  /** @var \Drupal\emr\EntityMetaStorageInterface $storage */
+  /** @var EntityMetaStorageInterface $storage */
   $storage = \Drupal::entityTypeManager()->getStorage('entity_meta');
   $meta_ids = $storage->getQuery()->allRevisions()->execute();
   $grouped = [];
@@ @@

   foreach ($grouped as $meta_id => $revision_ids) {
     foreach ($revision_ids as $revision_id) {
-      /** @var \Drupal\emr\Entity\EntityMetaInterface $revision */
+      /** @var EntityMetaInterface $revision */
       $revision = $storage->loadRevision($revision_id);
       $revision->set('emr_default_revision', $revision->isDefaultRevision());
       $revision->setNewRevision(FALSE);
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector


36) modules/contrib/entity_meta_relation/emr.install:0

    ---------- begin diff ----------
@@ @@
 <?php

+use Drupal\emr\EntityMetaStorageInterface;
 /**
  * @file
  * Entity Meta Relation install file.
@@ @@
  */
 function emr_update_8003(&$sandbox) {
   // Update the revisions.
-  /** @var \Drupal\emr\EntityMetaStorageInterface $storage */
+  /** @var EntityMetaStorageInterface $storage */
   $storage = \Drupal::entityTypeManager()->getStorage('entity_meta');
   if (!isset($sandbox['total'])) {
     $ids = $storage->getQuery()->allRevisions()->condition('emr_default_revision', 1)->execute();
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector


 [ERROR] Could not process                                                      
         "modules/contrib/entity_meta_relation/src/Field/ComputedHostEntityItemLis
         t.php" file, due to:                                                   
         "Analyze error: "Class                                                 
         Drupal\entity_reference_revisions\EntityReferenceRevisionsFieldItemList
         not found.". Include your files in                                     
         "$rectorConfig->autoloadPaths([...]);" or                              
         "$rectorConfig->bootstrapFiles([...]);" in "rector.php" config.        
         See https://github.com/rectorphp/rector#configuration".                

