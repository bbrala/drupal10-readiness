modules/contrib/micro_taxonomy/micro_taxonomy.install
modules/contrib/micro_taxonomy/micro_taxonomy.module
modules/contrib/micro_taxonomy/micro_taxonomy.post_update.php
modules/contrib/micro_taxonomy/src/Access/SiteTaxonomyAccess.php
modules/contrib/micro_taxonomy/src/Access/TabTermAccess.php
modules/contrib/micro_taxonomy/src/Form/MicroTaxonomyConfig.php
modules/contrib/micro_taxonomy/src/Form/SiteVocabularyForm.php
modules/contrib/micro_taxonomy/src/LocalTask/SiteTaxonomyLocalTask.php
modules/contrib/micro_taxonomy/src/MicroTaxonomyFields.php
modules/contrib/micro_taxonomy/src/MicroTaxonomyManager.php
modules/contrib/micro_taxonomy/src/MicroTaxonomyManagerInterface.php
modules/contrib/micro_taxonomy/src/Plugin/Derivative/ViewsAddLocalTasks.php
modules/contrib/micro_taxonomy/src/Plugin/EntityReferenceSelection/SiteTermSelection.php
modules/contrib/micro_taxonomy/src/Plugin/EntityReferenceSelection/SiteVocabularyTermSelection.php
modules/contrib/micro_taxonomy/src/Plugin/Menu/LocalAction/TermLinkAdd.php
modules/contrib/micro_taxonomy/src/Routing/RouteProcessor.php
modules/contrib/micro_taxonomy/src/Routing/RouteSubscriber.php
modules/contrib/micro_taxonomy/src/SiteTermAccessControlHandler.php
modules/contrib/micro_taxonomy/src/SiteVocabularyAccessControlHandler.php
modules/contrib/micro_taxonomy/tests/src/Functional/LoadTest.php

15 files with changes
=====================

1) modules/contrib/micro_taxonomy/tests/src/Functional/LoadTest.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\Tests\micro_taxonomy\Functional;

+use Drupal\user\UserInterface;
 use Drupal\Core\Url;
 use Drupal\Tests\BrowserTestBase;
 use Drupal\Tests\micro_site\Functional\MicroSiteBase;
@@ @@
   /**
    * A user with permission to administer site configuration.
    *
-   * @var \Drupal\user\UserInterface
+   * @var UserInterface
    */
   protected $user;

@@ @@
   /**
    * {@inheritdoc}
    */
-  protected function setUp() {
+  protected function setUp(): void {
     parent::setUp();
     $this->user = $this->drupalCreateUser(['administer site configuration']);
     $this->drupalLogin($this->user);
@@ @@
    */
   public function testLoad() {
     $this->drupalGet(Url::fromRoute('<front>'));
-    $this->assertResponse(200);
+    $this->assertSession()->statusCodeEquals(200);
   }

 }
    ----------- end diff -----------

Applied rules:
 * AssertResponseRector
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddReturnTypeDeclarationRector
 * ChangeMethodVisibilityRector


2) modules/contrib/micro_taxonomy/src/SiteTermAccessControlHandler.php:18

    ---------- begin diff ----------
@@ @@
   /**
    * The site negotiator.
    *
-   * @var \Drupal\micro_site\SiteNegotiatorInterface
+   * @var SiteNegotiatorInterface
    */
   protected $negotiator;

@@ @@
   /**
    * The micro taxonomy manager.
    *
-   * @var \Drupal\micro_taxonomy\MicroTaxonomyManagerInterface
+   * @var MicroTaxonomyManagerInterface
    */
   protected $taxonomyManager;

@@ @@
   /**
    * Check if two site entities are the same.
    *
-   * @param \Drupal\micro_site\Entity\SiteInterface|NULL $active_site
-   * @param \Drupal\micro_site\Entity\SiteInterface|NULL $term_site
+   * @param SiteInterface|NULL $active_site
+   * @param SiteInterface|NULL $term_site
    *
    * @return bool
    */
@@ @@
   /**
    * Gets the site negotiator.
    *
-   * @return \Drupal\micro_site\SiteNegotiatorInterface
+   * @return SiteNegotiatorInterface
    *   The site negotiator.
    */
   protected function negotiator() {
@@ @@
   /**
    * Gets the micro taxonomy manager.
    *
-   * @return \Drupal\micro_taxonomy\MicroTaxonomyManagerInterface
+   * @return MicroTaxonomyManagerInterface
    *   The micro taxonomy manager.
    */
   protected function taxonomyManager() {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


3) modules/contrib/micro_taxonomy/src/Routing/RouteProcessor.php:19

    ---------- begin diff ----------
@@ @@
   /**
    * The config factory.
    *
-   * @var \Drupal\Core\Config\ConfigFactoryInterface
+   * @var ConfigFactoryInterface
    */
   protected $configFactory;

@@ @@
   /**
    * The request stack object.
    *
-   * @var \Symfony\Component\HttpFoundation\RequestStack
+   * @var RequestStack
    */
   protected $requestStack;

@@ @@
   /**
    * Constructs a RouteProcessor object.
    *
-   * @param \Drupal\Core\Config\ConfigFactoryInterface $config_factory
+   * @param ConfigFactoryInterface $config_factory
    *   The config factory.
-   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   * @param EntityTypeManagerInterface $entity_type_manager
    *   The entity type manager service.
-   * @param \Symfony\Component\HttpFoundation\RequestStack $requestStack
+   * @param RequestStack $requestStack
    *   The request stack object.
    */
   function __construct(ConfigFactoryInterface $config_factory, EntityTypeManagerInterface $entity_type_manager, RequestStack $requestStack) {
@@ @@

     if (in_array($route_name, $routes_to_check)) {
       $request = $this->requestStack->getCurrentRequest();
-      /** @var \Drupal\micro_site\Entity\SiteInterface $site */
+      /** @var SiteInterface $site */
       $site = $request->get('site');
-      /** @var \Drupal\taxonomy\VocabularyInterface $taxonomy_vocabulary */
+      /** @var VocabularyInterface $taxonomy_vocabulary */
       $taxonomy_vocabulary = $request->get('taxonomy_vocabulary');

       // @TODO test if the active site is retrieved when we are on the site url.
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


4) modules/contrib/micro_taxonomy/src/Plugin/Menu/LocalAction/TermLinkAdd.php:15

    ---------- begin diff ----------
@@ @@
   /**
    * The redirect destination.
    *
-   * @var \Drupal\Core\Routing\RedirectDestinationInterface
+   * @var RedirectDestinationInterface
    */
   private $redirectDestination;

@@ @@
    *   The plugin_id for the plugin instance.
    * @param mixed $plugin_definition
    *   The plugin implementation definition.
-   * @param \Drupal\Core\Routing\RouteProviderInterface $route_provider
+   * @param RouteProviderInterface $route_provider
    *   The route provider to load routes by name.
-   * @param \Drupal\Core\Routing\RedirectDestinationInterface $redirect_destination
+   * @param RedirectDestinationInterface $redirect_destination
    *   The redirect destination.
    */
   public function __construct(array $configuration, $plugin_id, $plugin_definition, RouteProviderInterface $route_provider, RedirectDestinationInterface $redirect_destination) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


5) modules/contrib/micro_taxonomy/src/Plugin/EntityReferenceSelection/SiteVocabularyTermSelection.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\micro_taxonomy\Plugin\EntityReferenceSelection;

+use Drupal\taxonomy\TermInterface;
 use Drupal\Component\Utility\Html;
 use Drupal\Core\Form\FormStateInterface;
 use Drupal\micro_site\SiteNegotiatorInterface;
@@ @@
   /**
    * The site negotiator.
    *
-   * @var \Drupal\micro_site\SiteNegotiatorInterface
+   * @var SiteNegotiatorInterface
    */
   protected $negotiator;

@@ @@
     $has_admin_access = $this->currentUser->hasPermission('administer taxonomy');
     $unpublished_terms = [];
     if ($vocabulary = Vocabulary::load($bundle_name)) {
-      /** @var \Drupal\taxonomy\TermInterface[] $terms */
+      /** @var TermInterface[] $terms */
       if ($terms = $this->entityManager->getStorage('taxonomy_term')->loadTree($vocabulary->id(), 0, NULL, TRUE)) {
         foreach ($terms as $term) {
           if (!$has_admin_access && (!$term->isPublished() || in_array($term->parent->target_id, $unpublished_terms))) {
@@ @@
     $term = parent::createNewEntity($entity_type_id, $bundle, $label, $uid);

     // In order to create a referenceable term, it needs to published.
-    /** @var \Drupal\taxonomy\TermInterface $term */
+    /** @var TermInterface $term */
     $term->setPublished();
     if ($site = $this->negotiator()->getActiveSite()) {
       $term->set('site_id', $site);
@@ @@
     // Mirror the conditions checked in buildEntityQuery().
     if (!$this->currentUser->hasPermission('administer taxonomy')) {
       $entities = array_filter($entities, function ($term) {
-        /** @var \Drupal\taxonomy\TermInterface $term */
+        /** @var TermInterface $term */
         return $term->isPublished();
       });
     }
@@ @@
   /**
    * Gets the site negotiator.
    *
-   * @return \Drupal\micro_site\SiteNegotiatorInterface
+   * @return SiteNegotiatorInterface
    *   The site negotiator.
    */
   protected function negotiator() {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


6) modules/contrib/micro_taxonomy/src/Plugin/EntityReferenceSelection/SiteTermSelection.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\micro_taxonomy\Plugin\EntityReferenceSelection;

+use Drupal\taxonomy\TermInterface;
 use Drupal\Component\Utility\Html;
 use Drupal\Core\Entity\Plugin\EntityReferenceSelection\DefaultSelection;
 use Drupal\Core\Form\FormStateInterface;
@@ @@
   /**
    * The site negotiator.
    *
-   * @var \Drupal\micro_site\SiteNegotiatorInterface
+   * @var SiteNegotiatorInterface
    */
   protected $negotiator;

@@ @@
     $unpublished_terms = [];
     foreach ($bundle_names as $bundle) {
       if ($vocabulary = Vocabulary::load($bundle)) {
-        /** @var \Drupal\taxonomy\TermInterface[] $terms */
+        /** @var TermInterface[] $terms */
         if ($terms = $this->entityTypeManager->getStorage('taxonomy_term')->loadTree($vocabulary->id(), 0, NULL, TRUE)) {
           foreach ($terms as $term) {
             if (!$has_admin_access && (!$term->isPublished() || in_array($term->parent->target_id, $unpublished_terms))) {
@@ @@
     $term = parent::createNewEntity($entity_type_id, $bundle, $label, $uid);

     // In order to create a referenceable term, it needs to published.
-    /** @var \Drupal\taxonomy\TermInterface $term */
+    /** @var TermInterface $term */
     $term->setPublished();

     return $term;
@@ @@
     // Mirror the conditions checked in buildEntityQuery().
     if (!$this->currentUser->hasPermission('administer taxonomy')) {
       $entities = array_filter($entities, function ($term) {
-        /** @var \Drupal\taxonomy\TermInterface $term */
+        /** @var TermInterface $term */
         return $term->isPublished();
       });
     }
@@ @@
   /**
    * Gets the site negotiator.
    *
-   * @return \Drupal\micro_site\SiteNegotiatorInterface
+   * @return SiteNegotiatorInterface
    *   The site negotiator.
    */
   protected function negotiator() {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


7) modules/contrib/micro_taxonomy/src/Plugin/Derivative/ViewsAddLocalTasks.php:22

    ---------- begin diff ----------
@@ @@
   use StringTranslationTrait;

   /**
-   * @var \Drupal\Core\Entity\EntityTypeManagerInterface $entityTypeManager.
+   * @var EntityTypeManagerInterface $entityTypeManager .
    *
    * The entity type manager service.
    */
@@ @@
   /**
    * The config factory.
    *
-   * @var \Drupal\Core\Config\ConfigFactoryInterface
+   * @var ConfigFactoryInterface
    */
   protected $configFactory;

@@ @@
   /**
    * The site negotiator.
    *
-   * @var \Drupal\micro_site\SiteNegotiatorInterface
+   * @var SiteNegotiatorInterface
    */
   protected $negotiator;

@@ @@
   /**
    * The module handler.
    *
-   * @var \Drupal\Core\Extension\ModuleHandlerInterface
+   * @var ModuleHandlerInterface
    */
   protected $moduleHandler;

@@ @@
    *   The base plugin id.
    * @param EntityTypeManagerInterface $entity_type_manager
    *   The entity type manager service.
-   * @param \Drupal\Core\Config\ConfigFactoryInterface $config_factory
+   * @param ConfigFactoryInterface $config_factory
    *   The config factory.
-   * @param \Drupal\micro_site\SiteNegotiatorInterface $site_negotiator
+   * @param SiteNegotiatorInterface $site_negotiator
    *   The site negotiator.
-   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
+   * @param ModuleHandlerInterface $module_handler
    *   The module handler.
    */
   public function __construct($base_plugin_id, EntityTypeManagerInterface $entity_type_manager, ConfigFactoryInterface $config_factory, SiteNegotiatorInterface $site_negotiator, ModuleHandlerInterface $module_handler) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


8) modules/contrib/micro_taxonomy/src/MicroTaxonomyManagerInterface.php:53

    ---------- begin diff ----------
@@ @@
   /**
    * Get the main site from a node.
    *
-   * @param \Drupal\Core\Entity\EntityInterface $entity
+   * @param EntityInterface $entity
    *   The node to check.
    *
-   * @return \Drupal\micro_site\Entity\SiteInterface|NULL
+   * @return SiteInterface|NULL
    *   The site entity or NULL.
    */
   public function getSite(EntityInterface $entity);
@@ @@
   /**
    * Is the entity is available on all sites.
    *
-   * @param \Drupal\Core\Entity\EntityInterface $entity
+   * @param EntityInterface $entity
    *   The entity to retrieve field data from.
    *
    * @return boolean
@@ @@
   /**
    * Is the entity is available on the master.
    *
-   * @param \Drupal\Core\Entity\EntityInterface $entity
+   * @param EntityInterface $entity
    *   The entity to retrieve field data from.
    *
    * @return boolean
@@ @@
   /**
    * Get the users who can update terms.
    *
-   * @param \Drupal\micro_site\Entity\SiteInterface $site
+   * @param SiteInterface $site
    * @param bool $return_entity
    *
    * @return mixed
@@ @@
   /**
    * Get the users who can update terms.
    *
-   * @param \Drupal\micro_site\Entity\SiteInterface $site
+   * @param SiteInterface $site
    * @param bool $return_entity
    *
    * @return mixed
@@ @@
   /**
    * Get the users who can create terms.
    *
-   * @param \Drupal\micro_site\Entity\SiteInterface $site
+   * @param SiteInterface $site
    * @param bool $return_entity
    *
    * @return mixed
@@ @@


   /**
-   * @param \Drupal\Core\Session\AccountInterface $account
-   * @param \Drupal\micro_site\Entity\SiteInterface|NULL $site
+   * @param AccountInterface $account
+   * @param SiteInterface|NULL $site
    * @param $operation
    * @return mixed
    */
@@ @@
   public function userCanAccessTermOverview(AccountInterface $account, SiteInterface $site = NULL, $operation = '');

   /**
-   * @param \Drupal\Core\Session\AccountInterface $account
-   * @param \Drupal\micro_site\Entity\SiteInterface|NULL $site
+   * @param AccountInterface $account
+   * @param SiteInterface|NULL $site
    * @param $operation
    * @return mixed
    */
@@ @@
   public function userCanUpdateTerm(AccountInterface $account, SiteInterface $site = NULL, $operation = '');

   /**
-   * @param \Drupal\Core\Session\AccountInterface $account
-   * @param \Drupal\micro_site\Entity\SiteInterface|NULL $site
+   * @param AccountInterface $account
+   * @param SiteInterface|NULL $site
    * @param $operation
    * @return mixed
    */
@@ @@
   public function userCanDeleteTerm(AccountInterface $account, SiteInterface $site = NULL, $operation = '');

   /**
-   * @param \Drupal\Core\Session\AccountInterface $account
-   * @param \Drupal\micro_site\Entity\SiteInterface|NULL $site
+   * @param AccountInterface $account
+   * @param SiteInterface|NULL $site
    * @param $operation
    * @return mixed
    */
@@ @@
    * Alter the taxonomy term form.
    *
    * @param $form
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    * @param $form_id
-   * @param \Drupal\taxonomy\TermInterface $entity
+   * @param TermInterface $entity
    * @return mixed
    */
   public function alterTaxonomyTermForm(&$form, FormStateInterface $form_state, $form_id, TermInterface $entity);
@@ @@
    * Alter the form.
    *
    * @param array $form
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    * @param string $form_id
    */
   public function alterForm(&$form, FormStateInterface $form_state, $form_id);
@@ @@
    * Alter the content entity form.
    *
    * @param $form
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    * @param $form_id
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity
+   * @param ContentEntityInterface $entity
    * @return mixed
    */
   public function alterContentForm(&$form, FormStateInterface $form_state, $form_id, ContentEntityInterface $entity);
@@ @@
   /**
    * Create a dedicated vocabulary for site if set.
    *
-   * @param \Drupal\micro_site\Entity\SiteInterface $entity
+   * @param SiteInterface $entity
    * @return mixed
    */
   public function checkCreateSiteVocabulary(SiteInterface $entity);
@@ @@
   /**
    * Gets the object entity of the form if available.
    *
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The form state object.
    *
-   * @return \Drupal\Core\Entity\ContentEntityInterface|NULL
+   * @return ContentEntityInterface|NULL
    *   Entity or NULL if non-existent or if form operation is
    *   'delete'.
    */
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


9) modules/contrib/micro_taxonomy/src/MicroTaxonomyManager.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\micro_taxonomy;

+use Drupal\system\Entity\Menu;
+use Drupal\micro_site\Entity\SiteTypeInterface;
 use Drupal\Core\Access\AccessResult;
 use Drupal\Core\Config\ConfigFactoryInterface;
 use Drupal\Core\Entity\ContentEntityInterface;
@@ @@
   /**
    * The site record returned by the lookup request.
    *
-   * @var \Drupal\micro_site\Entity\SiteInterface
+   * @var SiteInterface
    */
   protected $site;

@@ @@
   /**
    * The entity type manager.
    *
-   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   * @var EntityTypeManagerInterface
    */
   protected $entityTypeManager;

@@ @@
   /**
    * The request stack object.
    *
-   * @var \Symfony\Component\HttpFoundation\RequestStack
+   * @var RequestStack
    */
   protected $requestStack;

@@ @@
   /**
    * The module handler.
    *
-   * @var \Drupal\Core\Extension\ModuleHandlerInterface
+   * @var ModuleHandlerInterface
    */
   protected $moduleHandler;

@@ @@
   /**
    * The config factory.
    *
-   * @var \Drupal\Core\Config\ConfigFactoryInterface
+   * @var ConfigFactoryInterface
    */
   protected $configFactory;

@@ @@
   /**
    * The site negotiator.
    *
-   * @var \Drupal\micro_site\SiteNegotiatorInterface
+   * @var SiteNegotiatorInterface
    */
   protected $negotiator;

@@ @@
   /**
    * Constructs a DomainNegotiator object.
    *
-   * @param \Symfony\Component\HttpFoundation\RequestStack $requestStack
+   * @param RequestStack $requestStack
    *   The request stack object.
-   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
+   * @param ModuleHandlerInterface $module_handler
    *   The module handler.
-   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   * @param EntityTypeManagerInterface $entity_type_manager
    *   The Domain loader object.
-   * @param \Drupal\Core\Config\ConfigFactoryInterface $config_factory
+   * @param ConfigFactoryInterface $config_factory
    *   The config factory.
-   * @param \Drupal\micro_site\SiteNegotiatorInterface $site_negotiator
+   * @param SiteNegotiatorInterface $site_negotiator
    *   The site negotiator.
    */
   public function __construct(RequestStack $requestStack, ModuleHandlerInterface $module_handler, EntityTypeManagerInterface $entity_type_manager, ConfigFactoryInterface $config_factory, SiteNegotiatorInterface $site_negotiator) {
@@ @@
    * {@inheritdoc}
    */
   public static function getCurrentSiteId() {
-    /** @var \Drupal\micro_site\Entity\SiteInterface $site */
+    /** @var SiteInterface $site */
     $site = \Drupal::service('micro_site.negotiator')->getActiveSite();

     // We are not on a active site url. Try to load it from the Request.
@@ @@
    * @inheritdoc
    */
   public function checkCreateSiteVocabulary(SiteInterface $entity) {
-    /** @var \Drupal\micro_site\Entity\SiteInterface $entity */
+    /** @var SiteInterface $entity */
     if (!$entity->hasVocabulary()) {
       return;
     }
     $site_vocabulary = $entity->getSiteVocabulary();
     if (empty($site_vocabulary)) {
-      /** @var \Drupal\system\Entity\Menu $menu */
+      /** @var Menu $menu */
       $vocabulary = Vocabulary::create([
         'vid' => 'site_' . $entity->id(),
         'name' => 'Vocabulary ' . $entity->label(),
@@ @@
     // Let's remove the entity reference taxonomy term fields which are not
     // allowed on the site type.
     if ($site instanceof SiteInterface) {
-      /** @var \Drupal\micro_site\Entity\SiteTypeInterface $site_type */
+      /** @var SiteTypeInterface $site_type */
       $site_type = $site->type->entity;
       $site_vocabularies = $site_type->getVocabularies();
       $fields = $entity->getFieldDefinitions();
-      /** @var \Drupal\Core\Field\FieldConfigInterface $field */
+      /** @var FieldConfigInterface $field */
       foreach ($fields as $field_name => $field) {
         if ($field instanceof FieldConfigInterface && $field->getType() == 'entity_reference') {
           $field_name = $field->getName();
@@ @@
     // site_vocabulary:taxonomy_term
     else {
       $fields = $entity->getFieldDefinitions();
-      /** @var \Drupal\Core\Field\FieldConfigInterface $field */
+      /** @var FieldConfigInterface $field */
       foreach ($fields as $field_name => $field) {
         if ($field instanceof FieldConfigInterface && $field->getType() == 'entity_reference') {
           $field_name = $field->getName();
@@ @@
    * @inheritdoc
    */
   public function alterTaxonomyTermForm(&$form, FormStateInterface $form_state, $form_id, TermInterface $entity) {
-    /** @var \Drupal\taxonomy\VocabularyInterface $vocabulary */
+    /** @var VocabularyInterface $vocabulary */
     $vocabulary = Vocabulary::load($entity->bundle());
     $vocabularies_enabled = $this->configFactory->get('micro_taxonomy.settings')->get('vocabularies');
     $account = \Drupal::currentUser();
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


10) modules/contrib/micro_taxonomy/src/Form/SiteVocabularyForm.php:22

    ---------- begin diff ----------
@@ @@
   /**
    * The site negotiator.
    *
-   * @var \Drupal\micro_site\SiteNegotiatorInterface
+   * @var SiteNegotiatorInterface
    */
   protected $negotiator;

@@ @@
   /**
    * Constructs a new vocabulary form.
    *
-   * @param \Drupal\taxonomy\VocabularyStorageInterface $vocabulary_storage
+   * @param VocabularyStorageInterface $vocabulary_storage
    *   The vocabulary storage.
-   * @param \Drupal\micro_site\SiteNegotiatorInterface $negotiator
+   * @param SiteNegotiatorInterface $negotiator
    *   The site negotiator.
    */
   public function __construct(VocabularyStorageInterface $vocabulary_storage, SiteNegotiatorInterface $negotiator) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


11) modules/contrib/micro_taxonomy/src/Form/MicroTaxonomyConfig.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\micro_taxonomy\Form;

+use Drupal\taxonomy\VocabularyInterface;
 use Drupal\Core\Form\ConfigFormBase;
 use Drupal\Core\Form\FormStateInterface;
 use Drupal\micro_site\Entity\Site;
@@ @@
     $config = $this->config('micro_taxonomy.settings');
     $options = [];

-    /** @var \Drupal\taxonomy\VocabularyInterface $vocabulary */
+    /** @var VocabularyInterface $vocabulary */
     foreach ($vocabularies as $vocabulary) {
       // We don't want to configure vocabularies dedicated to site entity.
       $site_id = $vocabulary->getThirdPartySetting('micro_taxonomy', 'site_id', '');
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


12) modules/contrib/micro_taxonomy/src/Access/TabTermAccess.php:32

    ---------- begin diff ----------
@@ @@
         return AccessResult::neutral('Site tab term can be access only on site registered.');
       }

-      /** @var \Drupal\micro_taxonomy\MicroTaxonomyManagerInterface $micro_taxonomy_manager */
+      /** @var MicroTaxonomyManagerInterface $micro_taxonomy_manager */
       $micro_taxonomy_manager = \Drupal::service('micro_taxonomy.manager');
       if ($micro_taxonomy_manager->userCanAccessTermOverview($account, $site, MicroTaxonomyManagerInterface::ACCESS_TAB_TERM)) {
         return AccessResult::allowed()->addCacheableDependency($site)->addCacheableDependency($account)->cachePerPermissions();
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


13) modules/contrib/micro_taxonomy/src/Access/SiteTaxonomyAccess.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\micro_taxonomy\Access;

+use Drupal\Core\Access\AccessResultInterface;
 use Drupal\Core\Access\AccessResult;
 use Drupal\Core\Routing\RouteMatchInterface;
 use Drupal\Core\Session\AccountInterface;
@@ @@
   /**
    * Checks access to the entity operation on the given route.
    *
-   * @param \Symfony\Component\Routing\Route $route
+   * @param Route $route
    *   The route to check against.
-   * @param \Drupal\Core\Routing\RouteMatchInterface $route_match
+   * @param RouteMatchInterface $route_match
    *   The parametrized route
-   * @param \Drupal\Core\Session\AccountInterface $account
+   * @param AccountInterface $account
    *   The currently logged in account.
-   * @param \Drupal\taxonomy\VocabularyInterface $taxonomy_vocabulary
+   * @param VocabularyInterface $taxonomy_vocabulary
    *   The menu on which check access.
-   * @param \Drupal\micro_site\Entity\SiteInterface $site
+   * @param SiteInterface $site
    *   The site entity.
    *
-   * @return \Drupal\Core\Access\AccessResultInterface
+   * @return AccessResultInterface
    *   The access result.
    */
   public function access(Route $route, RouteMatchInterface $route_match, AccountInterface $account, VocabularyInterface $taxonomy_vocabulary, SiteInterface $site = NULL) {
@@ @@

     if ($account->hasPermission('administer own micro vocabulary')) {

-      /** @var \Drupal\micro_taxonomy\MicroTaxonomyManagerInterface $micro_taxonomy_manager */
+      /** @var MicroTaxonomyManagerInterface $micro_taxonomy_manager */
       $micro_taxonomy_manager = \Drupal::service('micro_taxonomy.manager');
       if ($micro_taxonomy_manager->userCanAccessTermOverview($account, $site, MicroTaxonomyManagerInterface::ACCESS_OVERVIEW_TERM)) {
         return AccessResult::allowed()->addCacheableDependency($site)->addCacheableDependency($account)->cachePerPermissions();
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


14) modules/contrib/micro_taxonomy/micro_taxonomy.post_update.php:0

    ---------- begin diff ----------
@@ @@
 <?php

+use Drupal\Core\Config\Entity\ConfigEntityStorageInterface;
+use Drupal\Core\Config\Entity\ConfigEntityInterface;
 use Drupal\Core\Config\ExtensionInstallStorage;
 use Drupal\Core\Config\InstallStorage;
 use Drupal\Core\Entity\Entity\EntityFormDisplay;
@@ @@
   if (!\Drupal::moduleHandler()->moduleExists('views')) {
     return;
   }
-  /** @var \Drupal\Core\Config\Entity\ConfigEntityStorageInterface $view_storage */
+  /** @var ConfigEntityStorageInterface $view_storage */
   $view_storage = \Drupal::entityTypeManager()->getStorage('view');
-  /** @var \Drupal\Core\Config\Entity\ConfigEntityInterface $view */
+  /** @var ConfigEntityInterface $view */
   $view = $view_storage->load('site_taxonomy_term');
   if ($view instanceof ViewEntityInterface) {
     return;
   }

-  $config_path = drupal_get_path('module', 'micro_taxonomy') . '/' . InstallStorage::CONFIG_OPTIONAL_DIRECTORY;
+  $config_path = \Drupal::service('extension.list.module')->getPath('micro_taxonomy') . '/' . InstallStorage::CONFIG_OPTIONAL_DIRECTORY;
   $config_source = new FileStorage($config_path);
   \Drupal::service('config.installer')->installOptionalConfig($config_source);
 }
    ----------- end diff -----------

Applied rules:
 * DrupalGetPathRector
 * ArgumentRemoverRector


15) modules/contrib/micro_taxonomy/micro_taxonomy.module:0

    ---------- begin diff ----------
@@ @@
 <?php

+use Drupal\micro_taxonomy\MicroTaxonomyManagerInterface;
 /**
  * @file
  * Contains micro_taxonomy.module.
@@ @@
  * Implements hook_ENTITY_TYPE_insert().
  */
 function micro_taxonomy_site_insert(EntityInterface $entity) {
-  /** @var \Drupal\micro_taxonomy\MicroTaxonomyManagerInterface $micro_taxonomy_manager */
+  /** @var MicroTaxonomyManagerInterface $micro_taxonomy_manager */
   $micro_taxonomy_manager = \Drupal::service('micro_taxonomy.manager');
   if ($entity instanceof SiteInterface) {
     $micro_taxonomy_manager->checkCreateSiteVocabulary($entity);
@@ @@
  * Implements hook_ENTITY_TYPE_update().
  */
 function micro_taxonomy_site_update(EntityInterface $entity) {
-  /** @var \Drupal\micro_taxonomy\MicroTaxonomyManagerInterface $micro_taxonomy_manager */
+  /** @var MicroTaxonomyManagerInterface $micro_taxonomy_manager */
   $micro_taxonomy_manager = \Drupal::service('micro_taxonomy.manager');
   if ($entity instanceof SiteInterface) {
     $micro_taxonomy_manager->checkCreateSiteVocabulary($entity);
@@ @@
  * Implements hook_form_alter().
  */
 function micro_taxonomy_form_alter(&$form, FormStateInterface $form_state, $form_id) {
-  /** @var \Drupal\micro_taxonomy\MicroTaxonomyManagerInterface $micro_taxonomy_manager */
+  /** @var MicroTaxonomyManagerInterface $micro_taxonomy_manager */
   $micro_taxonomy_manager = \Drupal::service('micro_taxonomy.manager');
   $micro_taxonomy_manager->alterForm($form, $form_state, $form_id);
 }
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector


 [OK] 15 files have been changed by Rector                                      

