modules/contrib/meta_entity/meta_entity.install
modules/contrib/meta_entity/meta_entity.module
modules/contrib/meta_entity/src/Entity/MetaEntity.php
modules/contrib/meta_entity/src/Entity/MetaEntityInterface.php
modules/contrib/meta_entity/src/Entity/MetaEntityType.php
modules/contrib/meta_entity/src/Entity/MetaEntityTypeInterface.php
modules/contrib/meta_entity/src/Form/MetaEntityForm.php
modules/contrib/meta_entity/src/Form/MetaEntityTypeForm.php
modules/contrib/meta_entity/src/MetaEntityAccessControlHandler.php
modules/contrib/meta_entity/src/MetaEntityListBuilder.php
modules/contrib/meta_entity/src/MetaEntityPermissionProvider.php
modules/contrib/meta_entity/src/MetaEntityRepository.php
modules/contrib/meta_entity/src/MetaEntityRepositoryInterface.php
modules/contrib/meta_entity/src/MetaEntityReverseReferenceItemList.php
modules/contrib/meta_entity/src/MetaEntityServiceProvider.php
modules/contrib/meta_entity/src/MetaEntityTypeListBuilder.php
modules/contrib/meta_entity/src/Plugin/Validation/Constraint/MappedTargetEntity.php
modules/contrib/meta_entity/src/Plugin/Validation/Constraint/MappedTargetEntityValidator.php
modules/contrib/meta_entity/src/Plugin/Validation/Constraint/MetaEntityConstraintTrait.php
modules/contrib/meta_entity/src/Plugin/Validation/Constraint/UniquePerMetaTypeAndTarget.php
modules/contrib/meta_entity/src/Plugin/Validation/Constraint/UniquePerMetaTypeAndTargetValidator.php
modules/contrib/meta_entity/tests/modules/meta_entity_test/meta_entity_test.module
modules/contrib/meta_entity/tests/src/Functional/MetaEntityCacheTagsTest.php
modules/contrib/meta_entity/tests/src/Kernel/AutoCreationTest.php
modules/contrib/meta_entity/tests/src/Kernel/MappedTargetEntityConstraintTest.php
modules/contrib/meta_entity/tests/src/Kernel/MetaEntityAccessTest.php
modules/contrib/meta_entity/tests/src/Kernel/MetaEntityRepositoryTest.php
modules/contrib/meta_entity/tests/src/Kernel/MetaEntityTypeDependencyTest.php
modules/contrib/meta_entity/tests/src/Kernel/TargetEntityComputedFieldTest.php
modules/contrib/meta_entity/tests/src/Kernel/TargetEntityDependencyTest.php
modules/contrib/meta_entity/tests/src/Kernel/UniquePerMetaTypeAndTargetConstraintTest.php

14 files with changes
=====================

1) modules/contrib/meta_entity/tests/src/Kernel/MetaEntityAccessTest.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\Tests\meta_entity\Kernel;

+use Drupal\user\RoleInterface;
 use Drupal\entity_test\Entity\EntityTest;
 use Drupal\KernelTests\KernelTestBase;
 use Drupal\meta_entity\Entity\MetaEntity;
@@ @@
     ]);
     $meta_entity->save();

-    /** @var \Drupal\user\RoleInterface $role */
+    /** @var RoleInterface $role */
     $role = Role::create([
       'id' => $this->randomMachineName(),
       'label' => $this->randomString(),
    ----------- end diff -----------

Applied rules:
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * ChangeMethodVisibilityRector


2) modules/contrib/meta_entity/tests/src/Functional/MetaEntityCacheTagsTest.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\Tests\meta_entity\Functional;

+use Drupal\meta_entity\Entity\MetaEntityInterface;
+use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\Core\Cache\Cache;
 use Drupal\Core\Entity\EntityInterface;
 use Drupal\entity_test\Entity\EntityTest;
@@ @@
   /**
    * The meta entity.
    *
-   * @var \Drupal\meta_entity\Entity\MetaEntityInterface
+   * @var MetaEntityInterface
    */
   protected $entity;

@@ @@
   /**
    * An arbitrary entity.
    *
-   * @var \Drupal\Core\Entity\ContentEntityInterface
+   * @var ContentEntityInterface
    */
   protected $arbitraryEntity;

@@ @@
    */
   protected function getAdditionalCacheTagsForEntity(EntityInterface $entity) {
     $tags = parent::getAdditionalCacheTagsForEntity($entity);
-    /** @var \Drupal\meta_entity\Entity\MetaEntityInterface $entity */
+    /** @var MetaEntityInterface $entity */
     $tags = Cache::mergeTags($tags, $entity->getTargetEntity()->getCacheTags());
     // Add also an arbitrary cache tag.
     return Cache::mergeTags($tags, $this->arbitraryEntity->getCacheTags());
    ----------- end diff -----------

Applied rules:
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * AddReturnTypeDeclarationRector
 * ChangeMethodVisibilityRector


3) modules/contrib/meta_entity/src/Plugin/Validation/Constraint/UniquePerMetaTypeAndTargetValidator.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\meta_entity\Plugin\Validation\Constraint;

+use Drupal\dynamic_entity_reference\Plugin\Field\FieldType\DynamicEntityReferenceFieldItemList;
+use Drupal\Core\Entity\EntityInterface;
+use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\meta_entity\Entity\MetaEntityInterface;
 use Symfony\Component\Validator\Constraint;
 use Symfony\Component\Validator\ConstraintValidator;
@@ @@
    * {@inheritdoc}
    */
   public function validate($items, Constraint $constraint): void {
-    /** @var \Drupal\dynamic_entity_reference\Plugin\Field\FieldType\DynamicEntityReferenceFieldItemList $items */
+    /** @var DynamicEntityReferenceFieldItemList $items */
     $meta_entity = $items->getEntity();
-    /** @var \Drupal\Core\Entity\EntityInterface $meta_entity */
+    /** @var EntityInterface $meta_entity */
     if ($items->getFieldDefinition()->getName() !== 'target' || !$meta_entity instanceof MetaEntityInterface) {
       throw new \InvalidArgumentException("This constraint should be used only on field 'target' of an 'meta_entity' entity.");
     }

-    /** @var \Drupal\meta_entity\Plugin\Validation\Constraint\UniquePerMetaTypeAndTarget  $constraint */
+    /** @var UniquePerMetaTypeAndTarget $constraint */
     $query = \Drupal::entityQuery($constraint->metaEntityTypeId)->accessCheck(FALSE);
     $entity_id = $meta_entity->id();

@@ @@
       ->execute();

     if ($has_meta_entity) {
-      /** @var \Drupal\Core\Entity\ContentEntityInterface $target_entity */
+      /** @var ContentEntityInterface $target_entity */
       $target_entity = $items->entity;
       $this->context->buildViolation($constraint->message, [
         '%entity' => $target_entity->label(),
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


4) modules/contrib/meta_entity/src/Plugin/Validation/Constraint/MappedTargetEntityValidator.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\meta_entity\Plugin\Validation\Constraint;

+use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\Core\DependencyInjection\ContainerInjectionInterface;
 use Symfony\Component\DependencyInjection\ContainerAwareInterface;
 use Symfony\Component\DependencyInjection\ContainerAwareTrait;
@@ @@
   /**
    * Constructs a new validator instance.
    *
-   * @param \Symfony\Component\DependencyInjection\ContainerInterface $container
+   * @param ContainerInterface $container
    *   The service container.
    */
   public function __construct(ContainerInterface $container) {
@@ @@
    * {@inheritdoc}
    */
   public function validate($items, Constraint $constraint): void {
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $target_entity */
+    /** @var ContentEntityInterface $target_entity */
     $target_entity = $items->entity;
     if (empty($target_entity)) {
       return;
     }

-    /** @var \Drupal\meta_entity\Plugin\Validation\Constraint\MappedTargetEntity $constraint */
+    /** @var MappedTargetEntity $constraint */
     $repository = $this->container->get($this->container->getParameter('meta_entity.repositories')[$constraint->metaEntityTypeId]);
     $entity_types = $repository->getMetaEntityTypesForBundle($target_entity->getEntityTypeId(), $target_entity->bundle());
     if (!in_array($items->getEntity()->bundle(), $entity_types)) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


5) modules/contrib/meta_entity/src/MetaEntityReverseReferenceItemList.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\meta_entity;

+use Drupal\meta_entity\Entity\MetaEntityInterface;
 use Drupal\Core\Field\EntityReferenceFieldItemList;
 use Drupal\Core\TypedData\ComputedItemListTrait;

@@ @@

     foreach (\Drupal::getContainer()->getParameter('meta_entity.repositories') as $meta_entity_type_id => $service_id) {
       if ($this->getSetting('target_type') === $meta_entity_type_id) {
-        /** @var \Drupal\meta_entity\MetaEntityRepositoryInterface $repository */
+        /** @var MetaEntityRepositoryInterface $repository */
         $repository = \Drupal::service($service_id);
         if ($meta_entity = $repository->getMetaEntityForEntity($entity, $this->getSetting('meta_entity_type_id'))) {
           $this->list[0] = $this->createItem(0, $meta_entity);
@@ @@
   public function preSave() {
     $target_entity = $this->getEntity();
     foreach ($this->list as $item) {
-      /** @var \Drupal\meta_entity\Entity\MetaEntityInterface $meta_entity */
+      /** @var MetaEntityInterface $meta_entity */
       if (($meta_entity = $item->entity) && $meta_entity->isNew()) {
         if (!empty($target_entity->id())) {
           // The target entity is a new entity with an ID already set on
@@ @@
    */
   public function postSave($update): bool {
     foreach ($this->list as $item) {
-      /** @var \Drupal\meta_entity\Entity\MetaEntityInterface $meta_entity */
+      /** @var MetaEntityInterface $meta_entity */
       if (($meta_entity = $item->entity) && $meta_entity->get('target')->isEmpty()) {
         // Now that the parent ID exists, let's set the meta entity target.
         // @todo Sadly, we have to save once again the meta entity as it seems
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


6) modules/contrib/meta_entity/src/MetaEntityRepositoryInterface.php:16

    ---------- begin diff ----------
@@ @@
   /**
    * Sets the entity type manager service.
    *
-   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   * @param EntityTypeManagerInterface $entity_type_manager
    *   The entity type manager service.
    *
    * @return $this
@@ @@
   /**
    * Sets the cache chained backend.
    *
-   * @param \Drupal\Core\Cache\CacheBackendInterface $cache
+   * @param CacheBackendInterface $cache
    *   The cache chained backend.
    *
    * @return $this
@@ @@
   /**
    * Returns a list of meta entities of a given entity.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $target_entity
+   * @param ContentEntityInterface $target_entity
    *   The entity to checked.
    * @param string $meta_entity_bundle
    *   The meta entity bundle ID.
    *
-   * @return \Drupal\meta_entity\Entity\MetaEntityInterface|null
+   * @return MetaEntityInterface|null
    *   The meta entity or NULL if it doesn't exist.
    */
   public function getMetaEntityForEntity(ContentEntityInterface $target_entity, string $meta_entity_bundle): ?MetaEntityInterface;
@@ @@
   /**
    * Returns a list of existing meta entities of a given entity.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $target_entity
+   * @param ContentEntityInterface $target_entity
    *   The entity to checked.
    *
-   * @return \Drupal\meta_entity\Entity\MetaEntityInterface[]
+   * @return MetaEntityInterface[]
    *   Associative array keyed by meta entity ID with meta entity as value.
    */
   public function getMetaEntitiesForEntity(ContentEntityInterface $target_entity): array;
@@ @@
   /**
    * Returns a list of meta entity types that are configured with auto-creation.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $target_entity
+   * @param ContentEntityInterface $target_entity
    *   The entity for which to return the list.
    *
    * @return string[]
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


7) modules/contrib/meta_entity/src/MetaEntityRepository.php:17

    ---------- begin diff ----------
@@ @@
   /**
    * The entity type manager service.
    *
-   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   * @var EntityTypeManagerInterface
    */
   protected $entityTypeManager;

@@ @@
   /**
    * The cache chained backend.
    *
-   * @var \Drupal\Core\Cache\CacheBackendInterface
+   * @var CacheBackendInterface
    */
   protected $cache;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


8) modules/contrib/meta_entity/src/MetaEntityPermissionProvider.php:18

    ---------- begin diff ----------
@@ @@
   /**
    * The entity type manager service.
    *
-   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   * @var EntityTypeManagerInterface
    */
   protected $entityTypeManager;

@@ @@
   /**
    * Constructs a new permissions provider instance.
    *
-   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   * @param EntityTypeManagerInterface $entity_type_manager
    *   The entity type manager service.
    * @param string $entity_type_id
    *   The meta entity type ID.
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


9) modules/contrib/meta_entity/src/MetaEntityListBuilder.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\meta_entity;

+use Drupal\meta_entity\Entity\MetaEntityInterface;
 use Drupal\Core\Entity\EntityInterface;
 use Drupal\Core\Entity\EntityListBuilder;
 use Drupal\Core\Datetime\DateFormatterInterface;
@@ @@
   /**
    * The date formatter service.
    *
-   * @var \Drupal\Core\Datetime\DateFormatterInterface
+   * @var DateFormatterInterface
    */
   protected $dateFormatter;

@@ @@
   /**
    * The redirect destination service.
    *
-   * @var \Drupal\Core\Routing\RedirectDestinationInterface
+   * @var RedirectDestinationInterface
    */
   protected $redirectDestination;

@@ @@
   /**
    * Constructs a new EntityMetaListBuilder object.
    *
-   * @param \Drupal\Core\Entity\EntityTypeInterface $entity_type
+   * @param EntityTypeInterface $entity_type
    *   The entity type definition.
-   * @param \Drupal\Core\Entity\EntityStorageInterface $storage
+   * @param EntityStorageInterface $storage
    *   The entity storage class.
-   * @param \Drupal\Core\Datetime\DateFormatterInterface $date_formatter
+   * @param DateFormatterInterface $date_formatter
    *   The date formatter service.
-   * @param \Drupal\Core\Routing\RedirectDestinationInterface $redirect_destination
+   * @param RedirectDestinationInterface $redirect_destination
    *   The redirect destination service.
    */
   public function __construct(EntityTypeInterface $entity_type, EntityStorageInterface $storage, DateFormatterInterface $date_formatter, RedirectDestinationInterface $redirect_destination) {
@@ @@
    * {@inheritdoc}
    */
   public function buildRow(EntityInterface $entity) {
-    /** @var \Drupal\meta_entity\Entity\MetaEntityInterface $entity */
+    /** @var MetaEntityInterface $entity */
     $row['id'] = $entity->toLink();
     $row['type'] = $entity->get('type')->entity->label();
     return $row + parent::buildRow($entity);
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


10) modules/contrib/meta_entity/src/Form/MetaEntityTypeForm.php:3

    ---------- begin diff ----------
@@ @@

 namespace Drupal\meta_entity\Form;

+use Drupal\Core\Entity\EntityTypeBundleInfoInterface;
 use Drupal\Core\Entity\BundleEntityFormBase;
 use Drupal\Core\Entity\ContentEntityType;
 use Drupal\Core\Entity\EntityFieldManagerInterface;
@@ @@
   /**
    * The bundle info service.
    *
-   * @var \Drupal\Core\Entity\EntityTypeBundleInfoInterface
+   * @var EntityTypeBundleInfoInterface
    */
   protected $bundleInfo;

@@ @@
   /**
    * The entity field manager service.
    *
-   * @var \Drupal\Core\Entity\EntityFieldManagerInterface
+   * @var EntityFieldManagerInterface
    */
   protected $entityFieldManager;

@@ @@
   /**
    * Constructs a new form instance.
    *
-   * @param \Drupal\Core\Entity\EntityTypeBundleInfo $bundle_info
+   * @param EntityTypeBundleInfo $bundle_info
    *   The bundle info service.
-   * @param \Drupal\Core\Entity\EntityFieldManagerInterface $entity_field_manager
+   * @param EntityFieldManagerInterface $entity_field_manager
    *   The entity field manager.
    */
   public function __construct(EntityTypeBundleInfo $bundle_info, EntityFieldManagerInterface $entity_field_manager) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


11) modules/contrib/meta_entity/src/Form/MetaEntityForm.php:21

    ---------- begin diff ----------
@@ @@
     $link = $entity->toLink($this->t('View'))->toRenderable();

     $message_arguments = ['%label' => $this->getEntity()->label()];
-    $logger_arguments = $message_arguments + ['link' => render($link)];
+    $logger_arguments = $message_arguments + ['link' => \Drupal::service('renderer')->render($link)];

     if ($result === SAVED_NEW) {
       $this->logger('meta_entity')->notice('Created meta new entity %label', $logger_arguments);
    ----------- end diff -----------

Applied rules:
 * RenderRector
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


12) modules/contrib/meta_entity/src/Entity/MetaEntityInterface.php:31

    ---------- begin diff ----------
@@ @@
   /**
    * Return the entity this meta entity refers to.
    *
-   * @return \Drupal\Core\Entity\ContentEntityInterface|null
+   * @return ContentEntityInterface|null
    *   The entity this meta entity refers to.
    */
   public function getTargetEntity(): ?ContentEntityInterface;
@@ @@
    *
    * @param string $meta_entity_bundle
    *   The meta entity type bundle to be loaded or created.
-   * @param \Drupal\Core\Entity\ContentEntityInterface $target_entity
+   * @param ContentEntityInterface $target_entity
    *   The target content entity.
    *
    * @return \Drupal\meta_entity\Entity\MetaEntityInterface
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


13) modules/contrib/meta_entity/src/Entity/MetaEntity.php:150

    ---------- begin diff ----------
@@ @@
    *   The meta entity type ID to be loaded or created.
    * @param string $meta_entity_bundle
    *   The meta entity type bundle to be loaded or created.
-   * @param \Drupal\Core\Entity\ContentEntityInterface $target_entity
+   * @param ContentEntityInterface $target_entity
    *   The target content entity.
    *
-   * @return \Drupal\meta_entity\Entity\MetaEntityInterface
+   * @return MetaEntityInterface
    *   A meta entity.
    */
   protected static function loadOrCreateHelper(string $meta_entity_type_id, string $meta_entity_bundle, ContentEntityInterface $target_entity): MetaEntityInterface {
@@ @@
       ]);
     }

-    /** @var \Drupal\meta_entity\Entity\MetaEntityInterface $meta_entity */
+    /** @var MetaEntityInterface $meta_entity */
     return $meta_entity;
   }
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


14) modules/contrib/meta_entity/meta_entity.module:5

    ---------- begin diff ----------
@@ @@
  */

 declare(strict_types = 1);
+use Drupal\meta_entity\MetaEntityRepositoryInterface;
+use Drupal\Core\Entity\EntityTypeBundleInfoInterface;

 use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\Core\Entity\EntityInterface;
@@ @@

   $entity_type_manager = \Drupal::entityTypeManager();
   foreach (\Drupal::getContainer()->getParameter('meta_entity.repositories') as $meta_entity_type_id => $service_id) {
-    /** @var \Drupal\meta_entity\MetaEntityRepositoryInterface $repository */
+    /** @var MetaEntityRepositoryInterface $repository */
     $repository = \Drupal::service($service_id);
     if ($meta_entities = $repository->getMetaEntitiesForEntity($entity)) {
       $entity_type_manager->getStorage($meta_entity_type_id)->delete($meta_entities);
@@ @@
     return;
   }

-  /** @var \Drupal\Core\Entity\ContentEntityInterface $target_entity */
+  /** @var ContentEntityInterface $target_entity */
   if ($target_entity = $meta_entity->get('target')->entity) {
     $target_entity_singular_label = $target_entity->getEntityType()->getSingularLabel();
     $bundle_label = $meta_entity->get('type')->entity->label();
@@ @@
  * field is configurable in the meta entity type level.
  */
 function meta_entity_entity_bundle_field_info(EntityTypeInterface $entity_type, string $bundle, array $base_field_definitions): array {
-  /** @var \Drupal\Core\Entity\EntityTypeBundleInfoInterface $bundle_info */
+  /** @var EntityTypeBundleInfoInterface $bundle_info */
   $bundle_info = \Drupal::service('entity_type.bundle.info');
   $entity_type_id = $entity_type->id();

   $fields = [];
   foreach (\Drupal::getContainer()->getParameter('meta_entity.repositories') as $meta_entity_type_id => $service_id) {
-    /** @var \Drupal\meta_entity\MetaEntityRepositoryInterface $repository */
+    /** @var MetaEntityRepositoryInterface $repository */
     $repository = \Drupal::service($service_id);
     foreach ($repository->getReverseReferenceFieldNames($entity_type_id, $bundle) as $meta_entity_bundle => $field_name) {
-      /** @var \Drupal\Core\Field\BaseFieldDefinition $definition */
+      /** @var BaseFieldDefinition $definition */
       $bundle_label = $bundle_info->getBundleInfo($meta_entity_type_id)[$meta_entity_bundle]['label'];
       $fields[$field_name] = BaseFieldDefinition::create('entity_reference')
         ->setName($field_name)
@@ @@

   $entity_type_manager = \Drupal::entityTypeManager();
   foreach (\Drupal::getContainer()->getParameter('meta_entity.repositories') as $meta_entity_type_id => $service_id) {
-    /** @var \Drupal\meta_entity\MetaEntityRepositoryInterface $repository */
+    /** @var MetaEntityRepositoryInterface $repository */
     $repository = \Drupal::service($service_id);
     $meta_entity_bundles = $repository->getTypesWithAutoCreation($entity);
     if ($meta_entity_bundles) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector


 [OK] 14 files have been changed by Rector                                      

