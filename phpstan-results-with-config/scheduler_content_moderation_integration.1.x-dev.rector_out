modules/contrib/scheduler_content_moderation_integration/scheduler_content_moderation_integration.module
modules/contrib/scheduler_content_moderation_integration/scheduler_content_moderation_integration.tokens.inc
modules/contrib/scheduler_content_moderation_integration/src/EventSubscriber/SchedulerEventSubscriber.php
modules/contrib/scheduler_content_moderation_integration/src/Plugin/Field/FieldWidget/SchedulerModerationWidget.php
modules/contrib/scheduler_content_moderation_integration/src/Plugin/Validation/Constraint/ConstraintValidatorBase.php
modules/contrib/scheduler_content_moderation_integration/src/Plugin/Validation/Constraint/PublishStateConstraint.php
modules/contrib/scheduler_content_moderation_integration/src/Plugin/Validation/Constraint/PublishStateConstraintValidator.php
modules/contrib/scheduler_content_moderation_integration/src/Plugin/Validation/Constraint/TransitionAccessConstraint.php
modules/contrib/scheduler_content_moderation_integration/src/Plugin/Validation/Constraint/TransitionAccessConstraintValidator.php
modules/contrib/scheduler_content_moderation_integration/src/Plugin/Validation/Constraint/UnPublishStateConstraint.php
modules/contrib/scheduler_content_moderation_integration/src/Plugin/Validation/Constraint/UnPublishStateConstraintValidator.php
modules/contrib/scheduler_content_moderation_integration/tests/modules/scmi_testing/scmi_testing.module
modules/contrib/scheduler_content_moderation_integration/tests/src/Functional/EventsTest.php
modules/contrib/scheduler_content_moderation_integration/tests/src/Functional/FormsTest.php
modules/contrib/scheduler_content_moderation_integration/tests/src/Functional/LayoutBuilderTest.php
modules/contrib/scheduler_content_moderation_integration/tests/src/Functional/PublishedStateConstraintTest.php
modules/contrib/scheduler_content_moderation_integration/tests/src/Functional/SchedulerContentModerationBrowserTestBase.php
modules/contrib/scheduler_content_moderation_integration/tests/src/Functional/TokenReplaceTest.php
modules/contrib/scheduler_content_moderation_integration/tests/src/Functional/TransitionAccessTest.php
modules/contrib/scheduler_content_moderation_integration/tests/src/Functional/UnpublishedStateConstraintTest.php
modules/contrib/scheduler_content_moderation_integration/tests/src/Kernel/HookImplementationTest.php
modules/contrib/scheduler_content_moderation_integration/tests/src/Kernel/ModeratedContentSchedulingTest.php
modules/contrib/scheduler_content_moderation_integration/tests/src/Kernel/PublishedStateConstraintTest.php
modules/contrib/scheduler_content_moderation_integration/tests/src/Kernel/SchedulerContentModerationTestBase.php
modules/contrib/scheduler_content_moderation_integration/tests/src/Kernel/UnPublishedStateConstraintTest.php

14 files with changes
=====================

1) modules/contrib/scheduler_content_moderation_integration/tests/src/Kernel/UnPublishedStateConstraintTest.php:15

    ---------- begin diff ----------
@@ @@
   /**
    * {@inheritdoc}
    */
-  protected function setUp() {
+  protected function setUp(): void {
     parent::setUp();

     $user = $this->createMock('Drupal\Core\Session\AccountInterface');
    ----------- end diff -----------

Applied rules:
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * AssertEqualsParameterToSpecificMethodsTypeRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddReturnTypeDeclarationRector
 * ChangeMethodVisibilityRector


2) modules/contrib/scheduler_content_moderation_integration/tests/src/Kernel/SchedulerContentModerationTestBase.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\Tests\scheduler_content_moderation_integration\Kernel;

+use Drupal\content_moderation\ModerationInformationInterface;
+use Drupal\workflows\Entity\Workflow;
 use Drupal\Core\Datetime\Entity\DateFormat;
 use Drupal\KernelTests\KernelTestBase;
 use Drupal\node\Entity\NodeType;
@@ @@
   /**
    * Moderation info service.
    *
-   * @var \Drupal\content_moderation\ModerationInformationInterface
+   * @var ModerationInformationInterface
    */
   protected $moderationInfo;

@@ @@
   /**
    * The moderation workflow.
    *
-   * @var \Drupal\workflows\Entity\Workflow
+   * @var Workflow
    */
   protected $workflow;

@@ @@
   /**
    * {@inheritdoc}
    */
-  protected function setUp() {
+  protected function setUp(): void {
     parent::setUp();

     $this->installSchema('node', 'node_access');
    ----------- end diff -----------

Applied rules:
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddReturnTypeDeclarationRector
 * ChangeMethodVisibilityRector


3) modules/contrib/scheduler_content_moderation_integration/tests/src/Kernel/PublishedStateConstraintTest.php:15

    ---------- begin diff ----------
@@ @@
   /**
    * {@inheritdoc}
    */
-  protected function setUp() {
+  protected function setUp(): void {
     parent::setUp();

     $user = $this->createMock('Drupal\Core\Session\AccountInterface');
    ----------- end diff -----------

Applied rules:
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * AssertEqualsParameterToSpecificMethodsTypeRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddReturnTypeDeclarationRector
 * ChangeMethodVisibilityRector


4) modules/contrib/scheduler_content_moderation_integration/tests/src/Kernel/HookImplementationTest.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\Tests\scheduler_content_moderation_integration\Kernel;

+use Drupal\node\NodeInterface;
 use Drupal\node\Entity\Node;

 /**
@@ @@
   /**
    * A node of a type which is enabled for moderation.
    *
-   * @var \Drupal\node\NodeInterface
+   * @var NodeInterface
    */
   protected $moderatedNode;

@@ @@
   /**
    * A node of a type which is not enabled for moderation.
    *
-   * @var \Drupal\node\NodeInterface
+   * @var NodeInterface
    */
   protected $nonModeratedNode;

@@ @@
   /**
    * {@inheritdoc}
    */
-  public function setUp() {
+  public function setUp(): void {
     parent::setUp();

     // Create a user which has any permission required.
    ----------- end diff -----------

Applied rules:
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * AssertEqualsParameterToSpecificMethodsTypeRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * AddReturnTypeDeclarationRector
 * ChangeMethodVisibilityRector


5) modules/contrib/scheduler_content_moderation_integration/tests/src/Functional/TransitionAccessTest.php:91

    ---------- begin diff ----------
@@ @@
       'publish_state[0]' => 'published',
     ];
     $this->drupalGet("$entityTypeId/{$entity->id()}/edit");
-    $this->assertResponse(200, 'Scheduler user should be able to edit the entity."');
+    $this->assertSession()->statusCodeEquals(200, 'Scheduler user should be able to edit the entity."');
     $this->submitForm($edit, 'Save');

     $this->assertSession()
@@ @@
     // editing access should be denied.
     $this->drupalLogin($restrictedUser);
     $this->drupalGet("$entityTypeId/{$entity->id()}/edit");
-    $this->assertResponse(403, 'Restricted user should not be able to edit the entity."');
+    $this->assertSession()->statusCodeEquals(403, 'Restricted user should not be able to edit the entity."');

     // Remove scheduling info.
     $this->drupalLogin($schedulerUser);
@@ @@
     // (using 'create_new_draft' transition).
     $this->drupalLogin($restrictedUser);
     $this->drupalGet("$entityTypeId/{$entity->id()}/edit");
-    $this->assertResponse(200, 'Restricted user should be able to edit the entity."');
+    $this->assertSession()->statusCodeEquals(200, 'Restricted user should be able to edit the entity."');
     $this->submitForm([], 'Save');
     $this->assertSession()->pageTextContains(sprintf('%s has been updated.', $entity->label()));

@@ @@
       'unpublish_state[0]' => 'archived',
     ];
     $this->drupalGet("$entityTypeId/{$entity->id()}/edit");
-    $this->assertResponse(200, 'Scheduler user should be able to edit the entity."');
+    $this->assertSession()->statusCodeEquals(200, 'Scheduler user should be able to edit the entity."');
     $this->submitForm($edit, 'Save');

     $this->assertSession()
@@ @@
     // editing access should be denied.
     $this->drupalLogin($restrictedUser);
     $this->drupalGet("$entityTypeId/{$entity->id()}/edit");
-    $this->assertResponse(403, 'Restricted user should not be able to edit the entity."');
+    $this->assertSession()->statusCodeEquals(403, 'Restricted user should not be able to edit the entity."');

     // Remove scheduling info.
     $this->drupalLogin($schedulerUser);
@@ @@
     // Check entity is editable by restricted user when there is no scheduling.
     $this->drupalLogin($restrictedUser);
     $this->drupalGet("$entityTypeId/{$entity->id()}/edit");
-    $this->assertResponse(200, 'Restricted user should be able to edit the entity."');
+    $this->assertSession()->statusCodeEquals(200, 'Restricted user should be able to edit the entity."');
     $this->submitForm([], 'Save');
     $this->assertSession()->pageTextContains(sprintf('%s has been updated.', $entity->label()));
   }
    ----------- end diff -----------

Applied rules:
 * AssertResponseRector
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


6) modules/contrib/scheduler_content_moderation_integration/tests/src/Functional/SchedulerContentModerationBrowserTestBase.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\Tests\scheduler_content_moderation_integration\Functional;

+use Drupal\workflows\Entity\Workflow;
+use Drupal\Core\Entity\EntityTypeInterface;
 use Drupal\Tests\BrowserTestBase;
 use Drupal\Tests\content_moderation\Traits\ContentModerationTestTrait;
 use Drupal\Tests\scheduler\Traits\SchedulerSetupTrait;
@@ @@
   /**
    * The moderation workflow.
    *
-   * @var \Drupal\workflows\Entity\Workflow
+   * @var Workflow
    */
   protected $workflow;

@@ @@
   /**
    * {@inheritdoc}
    */
-  protected function setUp() {
+  protected function setUp(): void {
     parent::setUp();

     $this->drupalCreateContentType([
@@ @@
    * @param string $bundle
    *   The machine name of the bundle, for example 'page' or 'soundtrack'.
    *
-   * @return \Drupal\Core\Entity\EntityTypeInterface
+   * @return EntityTypeInterface
    *   The stored entity type object.
    */
   public function entityTypeObject(string $entityTypeId, string $bundle) {
    ----------- end diff -----------

Applied rules:
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * AddReturnTypeDeclarationRector
 * ChangeMethodVisibilityRector


7) modules/contrib/scheduler_content_moderation_integration/tests/src/Functional/FormsTest.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\Tests\scheduler_content_moderation_integration\Functional;

+use Drupal\Tests\WebAssert;
 /**
  * Test covering manipulation of add and edit entity forms.
  *
@@ @@
   public function testFormAlter($entityTypeId, $bundle, $operation) {
     $this->drupalLogin($this->schedulerUser);
     $entityType = $this->entityTypeObject($entityTypeId, $bundle);
-    /** @var \Drupal\Tests\WebAssert $assert */
+    /** @var WebAssert $assert */
     $assert = $this->assertSession();

     if ($operation == 'add') {
@@ @@
    */
   public function testFormAlterWithDeniedAccess($entityTypeId, $bundle, $operation) {
     $this->drupalLogin($this->schedulerUser);
-    /** @var \Drupal\Tests\WebAssert $assert */
+    /** @var WebAssert $assert */
     $assert = $this->assertSession();

     if ($operation == 'add') {
@@ @@

     // Check that both state fields are shown by default.
     $this->drupalGet($url);
-    $this->assertResponse(200, "The $operation form is displayed without error");
+    $this->assertSession()->statusCodeEquals(200, "The $operation form is displayed without error");
     $assert->FieldExists('publish_state[0]');
     $assert->FieldExists('unpublish_state[0]');

@@ @@

     // Check that both state fields are now hidden.
     $this->drupalGet($url);
-    $this->assertResponse(200, "The $operation form is displayed without error");
+    $this->assertSession()->statusCodeEquals(200, "The $operation form is displayed without error");
     $assert->FieldNotExists('publish_state[0]');
     $assert->FieldNotExists('unpublish_state[0]');
   }
    ----------- end diff -----------

Applied rules:
 * AssertResponseRector
 * ExceptionAnnotationRector
 * RemoveDataProviderTestPrefixRector
 * ArgumentRemoverRector
 * RenameAnnotationRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


8) modules/contrib/scheduler_content_moderation_integration/src/Plugin/Validation/Constraint/UnPublishStateConstraintValidator.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\scheduler_content_moderation_integration\Plugin\Validation\Constraint;

+use Drupal\Core\Entity\ContentEntityInterface;
 use Symfony\Component\Validator\Constraint;

 /**
@@ @@
    */
   public function validate($value, Constraint $constraint) {

-    /** @var \Drupal\Core\Entity\ContentEntityInterface $entity */
+    /** @var ContentEntityInterface $entity */
     $entity = $value->getEntity();

     // No need to validate entities that are not moderated.
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


9) modules/contrib/scheduler_content_moderation_integration/src/Plugin/Validation/Constraint/TransitionAccessConstraintValidator.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\scheduler_content_moderation_integration\Plugin\Validation\Constraint;

+use Drupal\Core\Field\FieldItemList;
 use Symfony\Component\Validator\Constraint;

 /**
@@ @@
    * {@inheritdoc}
    */
   public function validate($value, Constraint $constraint) {
-    /** @var \Drupal\Core\Field\FieldItemList $value */
+    /** @var FieldItemList $value */
     assert($constraint instanceof TransitionAccessConstraint);
     $entity = $value->getEntity();
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


10) modules/contrib/scheduler_content_moderation_integration/src/Plugin/Validation/Constraint/PublishStateConstraintValidator.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\scheduler_content_moderation_integration\Plugin\Validation\Constraint;

+use Drupal\Core\Entity\ContentEntityInterface;
 use Symfony\Component\Validator\Constraint;

 /**
@@ @@
    * {@inheritdoc}
    */
   public function validate($value, Constraint $constraint) {
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $entity */
+    /** @var ContentEntityInterface $entity */
     $entity = $value->getEntity();

     // No need to validate entities that are not moderated.
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


11) modules/contrib/scheduler_content_moderation_integration/src/Plugin/Validation/Constraint/ConstraintValidatorBase.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\scheduler_content_moderation_integration\Plugin\Validation\Constraint;

+use Drupal\Core\Session\AccountProxyInterface;
+use Drupal\workflows\WorkflowTypeInterface;
 use Drupal\content_moderation\ModerationInformationInterface;
 use Drupal\Core\DependencyInjection\ContainerInjectionInterface;
 use Drupal\Core\Entity\ContentEntityInterface;
@@ @@
   /**
    * The content moderation information service.
    *
-   * @var \Drupal\content_moderation\ModerationInformationInterface
+   * @var ModerationInformationInterface
    */
   protected $moderationInformation;

@@ @@
   /**
    * The current user.
    *
-   * @var \Drupal\Core\Session\AccountProxyInterface
+   * @var AccountProxyInterface
    */
   protected $account;

@@ @@
   /**
    * SchedulerModerationConstraintValidator constructor.
    *
-   * @param \Drupal\content_moderation\ModerationInformationInterface $moderationInformation
+   * @param ModerationInformationInterface $moderationInformation
    *   The content moderation information service.
-   * @param \Drupal\Core\Session\AccountInterface $account
+   * @param AccountInterface $account
    *   The current user.
    */
   public function __construct(
@@ @@
   /**
    * Gets the workflow type from the supplied entity's configured workflow.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity
+   * @param ContentEntityInterface $entity
    *   The content entity to get the workflow type for.
    *
-   * @return \Drupal\workflows\WorkflowTypeInterface
+   * @return WorkflowTypeInterface
    *   The workflow type.
    */
   protected function getEntityWorkflowType(ContentEntityInterface $entity) {
@@ @@
    * Validate that the transition between the supplied states is a valid
    * transition for the supplied entity.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity
+   * @param ContentEntityInterface $entity
    *   The entity containing the workflow to check against.
    * @param string $from_state
    *   The state to transition from.
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


12) modules/contrib/scheduler_content_moderation_integration/src/Plugin/Field/FieldWidget/SchedulerModerationWidget.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\scheduler_content_moderation_integration\Plugin\Field\FieldWidget;

+use Drupal\Core\Entity\EntityInterface;
 use Drupal\content_moderation\ModerationInformationInterface;
 use Drupal\Core\Entity\ContentEntityForm;
 use Drupal\Core\Field\FieldDefinitionInterface;
@@ @@
   /**
    * The moderation information service.
    *
-   * @var \Drupal\content_moderation\ModerationInformationInterface
+   * @var ModerationInformationInterface
    */
   protected $moderationInformation;

@@ @@
     // @todo Can this conditional ever be false? There is no test coverage for
     // that situation (if it exists).
     if ($form_state->getFormObject() instanceof ContentEntityForm) {
-      /** @var \Drupal\Core\Entity\EntityInterface $entity */
+      /** @var EntityInterface $entity */
       $entity = $form_state->getFormObject()->getEntity();
       if (!$this->moderationInformation->isModeratedEntity($entity)) {
         $element['#access'] = FALSE;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


13) modules/contrib/scheduler_content_moderation_integration/src/EventSubscriber/SchedulerEventSubscriber.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\scheduler_content_moderation_integration\EventSubscriber;

+use Drupal\Core\Entity\EntityInterface;
 use Drupal\scheduler\SchedulerEvent;
 use Drupal\scheduler\SchedulerEvents;
 use Symfony\Component\EventDispatcher\EventSubscriberInterface;
@@ @@
    *
    * This is during the edit process, not via cron.
    *
-   * @param \Drupal\scheduler\SchedulerEvent $event
+   * @param SchedulerEvent $event
    *   The event being acted on.
    */
   public function publishImmediately(SchedulerEvent $event) {
-    /** @var Drupal\Core\Entity\EntityInterface $entity */
+    /** @var EntityInterface $entity */
     $entity = $event->getNode();
     $entity->set('moderation_state', $entity->publish_state->getValue());
     $event->setNode($entity);
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


14) modules/contrib/scheduler_content_moderation_integration/scheduler_content_moderation_integration.module:0

    ---------- begin diff ----------
@@ @@
 <?php

+use Drupal\content_moderation\ModerationInformationInterface;
+use Drupal\workflows\WorkflowInterface;
+use Drupal\content_moderation\StateTransitionValidation;
+use Drupal\node\NodeTypeInterface;
+use Drupal\content_moderation\Plugin\WorkflowType\ContentModerationInterface;
+use Drupal\content_moderation\ContentModerationState;
 /**
  * @file
  * Scheduler Content Moderation Integration.
@@ @@
  * transitions.
  */
 function scheduler_content_moderation_integration_entity_access(EntityInterface $entity, $operation, AccountInterface $account) {
-  /** @var \Drupal\content_moderation\ModerationInformationInterface $moderation_info */
+  /** @var ModerationInformationInterface $moderation_info */
   $moderation_info = Drupal::service('content_moderation.moderation_information');

   if ($operation === 'update' && $moderation_info->isModeratedEntity($entity) && $entity->moderation_state) {
@@ @@
       $states[] = $entity->unpublish_state;
     }

-    /** @var \Drupal\workflows\WorkflowInterface $workflow */
+    /** @var WorkflowInterface $workflow */
     $workflow = $moderation_info->getWorkflowForEntity($entity);
     $current_state = $workflow->getTypePlugin()->getState($entity->moderation_state->value);
-    /** @var \Drupal\content_moderation\StateTransitionValidation $transition_validation */
+    /** @var StateTransitionValidation $transition_validation */
     $transition_validation = \Drupal::service('content_moderation.state_transition_validation');
     foreach ($states as $state) {
       try {
@@ @@
   // corresponding state selection field. If #access is already set to false
   // (for example by a third-party module) then do not override that setting.
   $config = \Drupal::config('scheduler.settings');
-  /** @var \Drupal\node\NodeTypeInterface $type */
+  /** @var NodeTypeInterface $type */
   $type = $form_state->getFormObject()->getEntity()->type->entity;
   $form['publish_state']['#access'] = ($form['publish_state']['#access'] ?? TRUE) && $type->getThirdPartySetting('scheduler', 'publish_enable', $config->get('default_publish_enable'));
   $form['unpublish_state']['#access'] = ($form['unpublish_state']['#access'] ?? TRUE) && $type->getThirdPartySetting('scheduler', 'unpublish_enable', $config->get('default_unpublish_enable'));
@@ @@
  * Helps on generating the options dynamically for the scheduler
  * moderation widget.
  *
- * @param \Drupal\Core\Field\FieldStorageDefinitionInterface $definition
+ * @param FieldStorageDefinitionInterface $definition
  *   The field storage definition.
- * @param \Drupal\Core\Entity\FieldableEntityInterface|null $entity
+ * @param FieldableEntityInterface|null $entity
  *   (optional) The entity context if known, or NULL if the allowed values are
  *   being collected without the context of a specific entity.
  * @param bool &$cacheable
@@ @@
     $workflow_storage = \Drupal::entityTypeManager()->getStorage('workflow');

     foreach ($workflow_storage->loadByProperties(['type' => 'content_moderation']) as $workflow) {
-      /** @var \Drupal\content_moderation\Plugin\WorkflowType\ContentModerationInterface $workflow_type */
+      /** @var ContentModerationInterface $workflow_type */
       $workflow_type = $workflow->getTypePlugin();

       foreach ($workflow_type->getStates() as $state_id => $state) {
@@ @@
     return $options;
   }

-  /** @var \Drupal\content_moderation\ModerationInformationInterface $moderation_information */
+  /** @var ModerationInformationInterface $moderation_information */
   $moderation_information = \Drupal::service('content_moderation.moderation_information');

   // Only add options for moderated entities.
@@ @@
     return $options;
   }

-  /** @var \Drupal\workflows\WorkflowInterface $workflow */
+  /** @var WorkflowInterface $workflow */
   $workflow = $moderation_information->getWorkflowForEntity($entity);

-  /** @var \Drupal\content_moderation\Plugin\WorkflowType\ContentModerationInterface $type_plugin */
+  /** @var ContentModerationInterface $type_plugin */
   $type_plugin = $workflow->getTypePlugin();

   $user = \Drupal::currentUser();
@@ @@
   $unpublish_state_options['_none'] = '';

   foreach ($user_transitions as $transition) {
-    /** @var \Drupal\content_moderation\ContentModerationState $state */
+    /** @var ContentModerationState $state */
     $state = $transition->to();
     // Check that this transition is valid from the current state.
     $ok_from_current = $current_state->canTransitionTo($state->id());
@@ @@
  * the scheduler publish_on field should be hidden.
  */
 function scheduler_content_moderation_integration_scheduler_hide_publish_on_field($form, $form_state, $node) {
-  /** @var \Drupal\content_moderation\ModerationInformationInterface $moderation_information */
+  /** @var ModerationInformationInterface $moderation_information */
   $moderation_information = \Drupal::service('content_moderation.moderation_information');

   $return = FALSE;
@@ @@
  * the scheduler unpublish_on field should be hidden.
  */
 function scheduler_content_moderation_integration_scheduler_hide_unpublish_on_field($form, $form_state, $node) {
-  /** @var \Drupal\content_moderation\ModerationInformationInterface $moderation_information */
+  /** @var ModerationInformationInterface $moderation_information */
   $moderation_information = \Drupal::service('content_moderation.moderation_information');

   $return = FALSE;
@@ @@
  * 0  if not moderated, to let Scheduler process the node as normal.
  */
 function scheduler_content_moderation_integration_scheduler_publish_action($node) {
-  /** @var \Drupal\content_moderation\ModerationInformationInterface $moderation_information */
+  /** @var ModerationInformationInterface $moderation_information */
   $moderation_information = \Drupal::service('content_moderation.moderation_information');

   if (!$moderation_information->isModeratedEntity($node)) {
@@ @@
   $state = $node->publish_state->value;
   $node->publish_state->value = NULL;

-  /** @var \Drupal\content_moderation\Plugin\WorkflowType\ContentModerationInterface $type_plugin */
+  /** @var ContentModerationInterface $type_plugin */
   $type_plugin = $moderation_information->getWorkflowForEntity($node)->getTypePlugin();
   try {
     // If transition is not valid, throw exception.
@@ @@
  * 0  if not moderated, to let Scheduler process the node as normal.
  */
 function scheduler_content_moderation_integration_scheduler_unpublish_action($node) {
-  /** @var \Drupal\content_moderation\ModerationInformationInterface $moderation_information */
+  /** @var ModerationInformationInterface $moderation_information */
   $moderation_information = \Drupal::service('content_moderation.moderation_information');

   if (!$moderation_information->isModeratedEntity($node)) {
@@ @@
   $state = $node->unpublish_state->value;
   $node->unpublish_state->value = NULL;

-  /** @var \Drupal\content_moderation\Plugin\WorkflowType\ContentModerationInterface $type_plugin */
+  /** @var ContentModerationInterface $type_plugin */
   $type_plugin = $moderation_information->getWorkflowForEntity($node)->getTypePlugin();
   try {
     // If transition is not valid, throw exception.
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector


 [OK] 14 files have been changed by Rector                                      

