modules/contrib/conflict/conflict.api.php
modules/contrib/conflict/conflict.module
modules/contrib/conflict/modules/conflict_paragraphs/conflict_paragraphs.module
modules/contrib/conflict/modules/conflict_paragraphs/src/ConflictResolution/MergeRemoteStructure.php
modules/contrib/conflict/modules/conflict_paragraphs/src/Plugin/Conflict/FieldComparator/FieldComparatorParagraphReference.php
modules/contrib/conflict/src/Annotation/FieldComparator.php
modules/contrib/conflict/src/ConflictDiscovery/ConflictDiscoveryBase.php
modules/contrib/conflict/src/ConflictDiscovery/ConflictDiscoveryInterface.php
modules/contrib/conflict/src/ConflictDiscovery/DefaultConflictDiscovery.php
modules/contrib/conflict/src/ConflictResolution/MergeRemoteOnlyChanges.php
modules/contrib/conflict/src/ConflictResolution/MergeStrategyBase.php
modules/contrib/conflict/src/ConflictResolution/MergeStrategyInterface.php
modules/contrib/conflict/src/ConflictResolver/ConflictResolverManager.php
modules/contrib/conflict/src/ConflictResolver/ConflictResolverManagerInterface.php
modules/contrib/conflict/src/ConflictTypes.php
modules/contrib/conflict/src/Entity/ConflictUIResolverHandlerInterface.php
modules/contrib/conflict/src/Entity/ContentEntityConflictHandler.php
modules/contrib/conflict/src/Entity/EntityConflictHandlerInterface.php
modules/contrib/conflict/src/Entity/EntityConflictUIResolverHandlerBase.php
modules/contrib/conflict/src/Event/EntityConflictDiscoveryEvent.php
modules/contrib/conflict/src/Event/EntityConflictEvents.php
modules/contrib/conflict/src/Event/EntityConflictResolutionEvent.php
modules/contrib/conflict/src/FieldComparatorInterface.php
modules/contrib/conflict/src/FieldComparatorManager.php
modules/contrib/conflict/src/FieldComparatorManagerInterface.php
modules/contrib/conflict/src/Form/ConflictResolutionDialogFormBuilder.php
modules/contrib/conflict/src/Form/ConflictResolutionInlineFormBuilder.php
modules/contrib/conflict/src/Form/EntityConflictFormHandlerInterface.php
modules/contrib/conflict/src/Plugin/Conflict/FieldComparator/FieldComparatorDefault.php
modules/contrib/conflict/tests/src/Kernel/SchemaTest.php

21 files with changes
=====================

1) modules/contrib/conflict/src/Form/EntityConflictFormHandlerInterface.php:10

    ---------- begin diff ----------
@@ @@
    *
    * @param array $form
    *   The form structure to fill in.
-   * @param \Drupal\Core\Entity\EntityInterface $entity_local_edited
+   * @param EntityInterface $entity_local_edited
    *   The locally edited entity.
-   * @param \Drupal\Core\Entity\EntityInterface $entity_local_edited
+   * @param EntityInterface $entity_local_edited
    *   The locally used original entity.
-   * @param \Drupal\Core\Entity\EntityInterface $entity_server
+   * @param EntityInterface $entity_server
    *   The unchanged entity loaded from the storage.
    */
   public function buildConflictForm(&$form, EntityInterface $entity_local_edited, EntityInterface $entity_local_original, EntityInterface $entity_server);
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


2) modules/contrib/conflict/src/Form/ConflictResolutionInlineFormBuilder.php:20

    ---------- begin diff ----------
@@ @@
   /**
    * The entity type manager.
    *
-   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   * @var EntityTypeManagerInterface
    */
   protected $entityTypeManager;

@@ @@
   /**
    * The module handler service.
    *
-   * @var \Drupal\Core\Extension\ModuleHandlerInterface
+   * @var ModuleHandlerInterface
    */
   protected $moduleHandler;

@@ @@
   /**
    * ConflictResolutionFormBuilder constructor.
    *
-   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   * @param EntityTypeManagerInterface $entity_type_manager
    *   The entity type manager.
-   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
+   * @param ModuleHandlerInterface $module_handler
    *   The module handler
-   * @param \Drupal\Core\StringTranslation\TranslationInterface $string_translation
+   * @param TranslationInterface $string_translation
    *   The string translation service.
    */
   public function __construct(EntityTypeManagerInterface $entity_type_manager, ModuleHandlerInterface $module_handler, TranslationInterface $string_translation) {
@@ @@
    *
    * @param $form
    *   The form array.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The current state of the form.
-   * @param \Drupal\Core\Entity\EntityInterface $entity
+   * @param EntityInterface $entity
    *   The entity of the form.
    */
   public function processForm(&$form, FormStateInterface $form_state, EntityInterface $entity) {
@@ @@
       return;
     }

-    /** @var \Drupal\conflict\Entity\EntityConflictHandlerInterface $entity_conflict_resolution_handler */
+    /** @var EntityConflictHandlerInterface $entity_conflict_resolution_handler */
     $entity_conflict_resolution_handler = $this->entityTypeManager->getHandler($entity->getEntityTypeId(), 'conflict.resolution_handler');

-    /** @var \Drupal\Core\Entity\ContentEntityInterface $entity_local_original */
+    /** @var ContentEntityInterface $entity_local_original */
     $entity_local_original = $entity->{EntityConflictHandlerInterface::CONFLICT_ENTITY_ORIGINAL};
     $entity_server = $entity->{EntityConflictHandlerInterface::CONFLICT_ENTITY_SERVER};
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


3) modules/contrib/conflict/src/Form/ConflictResolutionDialogFormBuilder.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\conflict\Form;

+use Drupal\Core\Entity\EntityFormInterface;
+use Drupal\Core\Field\FieldItemInterface;
+use Drupal\conflict\Entity\EntityConflictHandlerInterface;
+use Drupal\conflict\Entity\ConflictUIResolverHandlerInterface;
 use Drupal\Core\Ajax\AjaxResponse;
 use Drupal\Core\Ajax\CloseDialogCommand;
 use Drupal\Core\Ajax\CloseModalDialogCommand;
@@ @@
   /**
    * The entity type manager.
    *
-   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   * @var EntityTypeManagerInterface
    */
   protected $entityTypeManager;

@@ @@
   /**
    * ConflictResolutionFormBuilder constructor.
    *
-   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   * @param EntityTypeManagerInterface $entity_type_manager
    *   The entity type manager.
    */
   public function __construct(EntityTypeManagerInterface $entity_type_manager) {
@@ @@
    *
    * @param $form
    *   The form array.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The current state of the form.
    */
   public function processForm(&$form, FormStateInterface $form_state) {
@@ @@
    *
    * @param $form
    *   The form array.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The current state of the form.
    */
   public function resolveConflictsSubmit($form, FormStateInterface $form_state) {
@@ @@
    *
    * @param $form
    *   The form array.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The current state of the form.
    *
-   * @return \Drupal\Core\Ajax\AjaxResponse
+   * @return AjaxResponse
    *   The ajax response containing the conflict resolution UI.
    */
   public function resolveConflictsAjax($form, FormStateInterface $form_state) {
@@ @@
    *
    * @param $path
    *   The property path.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The current state of the form.
    *
    * @return array
@@ @@
   protected static function getTitleForPropertyPath($path, FormStateInterface $form_state) {
     $titles = [];
     $parents = $path ? explode('.', $path) : [];
-    /** @var \Drupal\Core\Entity\EntityFormInterface $form_object */
+    /** @var EntityFormInterface $form_object */
     $form_object = $form_state->getFormObject();
     $element = $form_object->getEntity();
     $langcode = $element->language()->getId();
@@ @@
           throw new \Exception('Not supported structure.');
         }

-        /** @var \Drupal\Core\Field\FieldItemInterface $field_item */
+        /** @var FieldItemInterface $field_item */
         $field_item = $element->get($next_element_identifier);
         $properties = $field_item->getProperties(TRUE);
         if (!isset($properties['entity'])) {
@@ @@
           throw new \Exception('Not supported structure.');
         }

-        /** @var \Drupal\Core\Entity\ContentEntityInterface $element */
+        /** @var ContentEntityInterface $element */
         $element = $field_item->entity;
         if ($element->hasTranslation($langcode)) {
           $element = $element->getTranslation($langcode);
@@ @@
    *
    * @param $path
    *   The property path.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The current state of the form.
    *
-   * @return \Drupal\Core\Entity\EntityInterface[]
+   * @return EntityInterface[]
    *   The entities across the path.
    *
    * @throws \Exception
@@ @@
    */
   protected static function getEntitiesForPropertyPath($path, FormStateInterface $form_state) {
     $parents = $path ? explode('.', $path) : [];
-    /** @var \Drupal\Core\Entity\EntityFormInterface $form_object */
+    /** @var EntityFormInterface $form_object */
     $form_object = $form_state->getFormObject();
     $element = $form_object->getEntity();
     $langcode = $element->language()->getId();
@@ @@
         if (!isset($element[$next_element_identifier])) {
           throw new \Exception('Not supported structure.');
         }
-        /** @var \Drupal\Core\Field\FieldItemInterface $field_item */
+        /** @var FieldItemInterface $field_item */
         $field_item = $element->get($next_element_identifier);
         $properties = $field_item->getProperties(TRUE);
         if (!isset($properties['entity'])) {
@@ @@
           throw new \Exception('Not supported structure.');
         }

-        /** @var \Drupal\Core\Entity\ContentEntityInterface $element */
+        /** @var ContentEntityInterface $element */
         $element = $field_item->entity;
         if ($element->hasTranslation($langcode)) {
           $element = $element->getTranslation($langcode);
@@ @@
    * @param string $entity_type_id
    *   The entity type ID.
    *
-   * @return \Drupal\conflict\Entity\EntityConflictHandlerInterface
+   * @return EntityConflictHandlerInterface
    */
   protected function getEntityConflictHandler($entity_type_id) {
     return $this->entityTypeManager->getHandler($entity_type_id, 'conflict.resolution_handler');
@@ @@
    * @param string $entity_type_id
    *   The entity type ID.
    *
-   * @return \Drupal\conflict\Entity\ConflictUIResolverHandlerInterface
+   * @return ConflictUIResolverHandlerInterface
    */
   protected function getEntityConflictUIResolver($entity_type_id) {
     return $this->entityTypeManager->getHandler($entity_type_id, 'conflict_ui_resolver');
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


4) modules/contrib/conflict/src/FieldComparatorManagerInterface.php:9

    ---------- begin diff ----------
@@ @@
   /**
    * Compares two field item lists.
    *
-   * @param \Drupal\Core\Field\FieldItemListInterface $items_a
+   * @param FieldItemListInterface $items_a
    *   The first field item list to compare.
-   * @param \Drupal\Core\Field\FieldItemListInterface $items_a
+   * @param FieldItemListInterface $items_a
    *   The second field item list to compare.
    * @param string $langcode
    *   The language code of the entity translation being checked.
@@ @@
   /**
    * Returns the conflict type for a field.
    *
-   * @param \Drupal\Core\Field\FieldItemListInterface $local
+   * @param FieldItemListInterface $local
    *   The local field item list to compare.
-   * @param \Drupal\Core\Field\FieldItemListInterface $server
+   * @param FieldItemListInterface $server
    *   The server field item list to compare.
-   * @param \Drupal\Core\Field\FieldItemListInterface $original
+   * @param FieldItemListInterface $original
    *   The original field item list, from which local and the server emerged.
    * @param string $langcode
    *   The language code of the entity translation being checked.
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


5) modules/contrib/conflict/src/FieldComparatorManager.php:30

    ---------- begin diff ----------
@@ @@
    * @param \Traversable $namespaces
    *   An object that implements \Traversable which contains the root paths
    *   keyed by the corresponding namespace to look for plugin implementations.
-   * @param \Drupal\Core\Cache\CacheBackendInterface $cache_backend
+   * @param CacheBackendInterface $cache_backend
    *   Cache backend instance to use.
-   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
+   * @param ModuleHandlerInterface $module_handler
    *   The module handler.
    */
   public function __construct(\Traversable $namespaces, CacheBackendInterface $cache_backend, ModuleHandlerInterface $module_handler) {
@@ @@
   public function getConflictType(FieldItemListInterface $local, FieldItemListInterface $server, FieldItemListInterface $original, $langcode, $entity_type_id, $bundle, $field_type, $field_name) {
     // Iterate from the most specific to the most general comparator.
     foreach ($this->getOrderedFieldComparators($entity_type_id, $bundle, $field_type, $field_name) as &$comparator) {
-      /** @var \Drupal\conflict\FieldComparatorInterface $comparator */
+      /** @var FieldComparatorInterface $comparator */
       if (!is_object($comparator)) {
         $comparator = $this->createInstance($comparator);
       }
@@ @@
   public function hasChanged(FieldItemListInterface $items_a, FieldItemListInterface $items_b, $langcode, $entity_type_id, $bundle, $field_type, $field_name) {
     // Iterate from the most specific to the most general comparator.
     foreach ($this->getOrderedFieldComparators($entity_type_id, $bundle, $field_type, $field_name) as &$comparator) {
-      /** @var \Drupal\conflict\FieldComparatorInterface $comparator */
+      /** @var FieldComparatorInterface $comparator */
       if (!is_object($comparator)) {
         $comparator = $this->createInstance($comparator);
       }
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


6) modules/contrib/conflict/src/FieldComparatorInterface.php:17

    ---------- begin diff ----------
@@ @@
   /**
    * Checks whether the field items have changed.
    *
-   * @param \Drupal\Core\Field\FieldItemListInterface $field_item_list_a
+   * @param FieldItemListInterface $field_item_list_a
    *   A field item list.
-   * @param \Drupal\Core\Field\FieldItemListInterface $field_item_list_b
+   * @param FieldItemListInterface $field_item_list_b
    *   Another field item list.
    * @param string $langcode
    *   (optional) The language code of the entity translation being checked.
@@ @@
   /**
    * Returns the conflict type for a field.
    *
-   * @param \Drupal\Core\Field\FieldItemListInterface $local
+   * @param FieldItemListInterface $local
    *   The local field item list to compare.
-   * @param \Drupal\Core\Field\FieldItemListInterface $server
+   * @param FieldItemListInterface $server
    *   The server field item list to compare.
-   * @param \Drupal\Core\Field\FieldItemListInterface $original
+   * @param FieldItemListInterface $original
    *   The original field item list, from which local and the server emerged.
    * @param string $langcode
    *   The language code of the entity translation being checked.
@@ @@
   /**
    * Returns if the field comparator can be used for the provided field.
    *
-   * @param \Drupal\Core\Field\FieldDefinitionInterface $field_definition
+   * @param FieldDefinitionInterface $field_definition
    *   The field definition that should be checked.
    *
    * @return bool
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


7) modules/contrib/conflict/src/Event/EntityConflictResolutionEvent.php:9

    ---------- begin diff ----------
@@ @@
   /**
    * The result entity.
    *
-   * @var \Drupal\Core\Entity\EntityInterface
+   * @var EntityInterface
    */
   protected $resultEntity;

@@ @@
   /**
    * Constructs a conflict discovery event object.
    *
-   * @param \Drupal\Core\Entity\EntityInterface $local
+   * @param EntityInterface $local
    *   The local part of the comparision - for example the entity built of the
    *   user input on an entity form submission. This is basically the active
    *   entity object.
-   * @param \Drupal\Core\Entity\EntityInterface $remote
+   * @param EntityInterface $remote
    *   The remote part of the comparision - for example the current version of
    *   the entity from the storage.
-   * @param \Drupal\Core\Entity\EntityInterface $base
+   * @param EntityInterface $base
    *   The initial entity version in concurrent editing or the lowest common
    *   ancestor in a revision tree scenario.
-   * @param \Drupal\Core\Entity\EntityInterface $result
+   * @param EntityInterface $result
    *   The result entity, on which to apply the result. Usually this will be the
    *   active entity object - the local entity.
    * @param array $conflicts
    *   The conflicts.
-   * @param \Symfony\Component\HttpFoundation\ParameterBag $context
+   * @param ParameterBag $context
    *   (optional) The context parameter bag.
    */
   public function __construct(EntityInterface $local, EntityInterface $remote, EntityInterface $base, EntityInterface $result, array $conflicts, ParameterBag $context = NULL) {
@@ @@
    *
    * @param \Drupal\conflict\Event\EntityConflictDiscoveryEvent
    *   The conflict discovery event.
-   * @param \Drupal\Core\Entity\EntityInterface $result
+   * @param EntityInterface $result
    *   The result entity, on which to apply the result.
    *
    * @return static
@@ @@
   /**
    * Returns the result entity.
    *
-   * @return \Drupal\Core\Entity\EntityInterface
+   * @return EntityInterface
    */
   public function getResultEntity() : EntityInterface {
     return $this->resultEntity;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


8) modules/contrib/conflict/src/Event/EntityConflictDiscoveryEvent.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\conflict\Event;

+use Symfony\Contracts\EventDispatcher\Event;
 use Drupal\Core\Entity\EntityInterface;
-use Symfony\Component\EventDispatcher\Event;
 use Symfony\Component\HttpFoundation\ParameterBag;

 class EntityConflictDiscoveryEvent extends Event {
@@ @@
   /**
    * The local entity.
    *
-   * @var \Drupal\Core\Entity\EntityInterface
+   * @var EntityInterface
    */
   protected $localEntity;

@@ @@
   /**
    * The remote entity.
    *
-   * @var \Drupal\Core\Entity\EntityInterface
+   * @var EntityInterface
    */
   protected $remoteEntity;

@@ @@
   /**
    * The base entity.
    *
-   * @var \Drupal\Core\Entity\EntityInterface
+   * @var EntityInterface
    */
   protected $baseEntity;

@@ @@
    *
    * It might contain configuration and/or form data during concurrent editing.
    *
-   * @var \Symfony\Component\HttpFoundation\ParameterBag
+   * @var ParameterBag
    */
   protected $context;

@@ @@
   /**
    * Constructs a conflict discovery event object.
    *
-   * @param \Drupal\Core\Entity\EntityInterface $local
+   * @param EntityInterface $local
    *   The local part of the comparision - for example the entity built of the
    *   user input on an entity form submission. This is basically the active
    *   entity object.
-   * @param \Drupal\Core\Entity\EntityInterface $remote
+   * @param EntityInterface $remote
    *   The remote part of the comparision - for example the current version of
    *   the entity from the storage.
-   * @param \Drupal\Core\Entity\EntityInterface $base
+   * @param EntityInterface $base
    *   The initial entity version in concurrent editing or the lowest common
    *   ancestor in a revision tree scenario.
-   * @param \Symfony\Component\HttpFoundation\ParameterBag $context
+   * @param ParameterBag $context
    *   (optional) The context parameter bag.
    */
   public function __construct(EntityInterface $local, EntityInterface $remote, EntityInterface $base, ParameterBag $context = NULL) {
@@ @@
   /**
    * Return the local entity.
    *
-   * @return \Drupal\Core\Entity\EntityInterface
+   * @return EntityInterface
    */
   public function getLocalEntity() : EntityInterface {
     return $this->localEntity;
@@ @@
   /**
    * Returns the remote entity.
    *
-   * @return \Drupal\Core\Entity\EntityInterface
+   * @return EntityInterface
    */
   public function getRemoteEntity() : EntityInterface {
     return $this->remoteEntity;
@@ @@
   /**
    * Returns the base entity.
    *
-   * @return \Drupal\Core\Entity\EntityInterface
+   * @return EntityInterface
    */
   public function getBaseEntity() : EntityInterface {
     return $this->baseEntity;
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * RenameClassRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


9) modules/contrib/conflict/src/Entity/EntityConflictHandlerInterface.php:41

    ---------- begin diff ----------
@@ @@
    *
    * @param array $form
    *   The entity form to be altered to provide the translation workflow.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The current state of the form.
-   * @param \Drupal\Core\Entity\EntityInterface $entity
+   * @param EntityInterface $entity
    *   The entity being created or edited.
    * @param bool $inline_entity_form
    *   (optional) TRUE if an inline entity form is given, FALSE if a regular
@@ @@
   /**
    * Returns the entity conflicts.
    *
-   * @param \Drupal\Core\Entity\EntityInterface $entity_local_original
+   * @param EntityInterface $entity_local_original
    *   The locally edited entity.
-   * @param \Drupal\Core\Entity\EntityInterface $entity_local_edited
+   * @param EntityInterface $entity_local_edited
    *   The original not edited entity used to build the form.
-   * @param \Drupal\Core\Entity\EntityInterface $entity_server
+   * @param EntityInterface $entity_server
    *   The unchanged entity loaded from the storage.
    *
    * @return array
@@ @@
   /**
    * Finishes the conflict resolution after the user interaction (manual merge).
    *
-   * @param \Drupal\Core\Entity\EntityInterface $entity
+   * @param EntityInterface $entity
    *   The entity.
    * @param array $path_parents
    *   The parents to the entity.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *  The current state of the form.
    */
   public function finishConflictResolution(EntityInterface $entity, $path_parents, FormStateInterface $form_state);
@@ @@
   /**
    * Prepares the entity for the manual conflict resolution.
    *
-   * @param \Drupal\Core\Entity\EntityInterface $entity
+   * @param EntityInterface $entity
    *   The current entity.
-   * @param \Drupal\Core\Entity\EntityInterface $entity_server
+   * @param EntityInterface $entity_server
    *   (optional) The server entity i.e. the current entity from the storage or
    *   NULL if the entity has been deleted or in case of inline reference the
    *   relationship was removed.
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


10) modules/contrib/conflict/src/Entity/ContentEntityConflictHandler.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\conflict\Entity;

+use Drupal\Core\Entity\ContentEntityTypeInterface;
+use Drupal\Core\Entity\EntityStorageInterface;
+use Drupal\Core\Entity\ContentEntityFormInterface;
 use Drupal\Component\Utility\NestedArray;
 use Drupal\conflict\ConflictResolver\ConflictResolverManagerInterface;
 use Drupal\conflict\ConflictTypes;
@@ @@
   /**
    * The entity type.
    *
-   * @var \Drupal\Core\Entity\ContentEntityTypeInterface
+   * @var ContentEntityTypeInterface
    */
   protected $entityType;

@@ @@
   /**
    * The entity type manager.
    *
-   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   * @var EntityTypeManagerInterface
    */
   protected $entityTypeManager;

@@ @@
   /**
    * The module handler to invoke the alter hook.
    *
-   * @var \Drupal\Core\Extension\ModuleHandlerInterface
+   * @var ModuleHandlerInterface
    */
   protected $moduleHandler;

@@ @@
   /**
    * The entity storage.
    *
-   * @var \Drupal\Core\Entity\EntityStorageInterface
+   * @var EntityStorageInterface
    */
   protected $storage;

@@ @@
   /**
    * The key value store storing the original entity.
    *
-   * @var \Drupal\Core\KeyValueStore\KeyValueStoreInterface
+   * @var KeyValueStoreInterface
    */
   protected $keyValueOriginalEntity;

@@ @@
   /**
    * The field comparator manager.
    *
-   * @var \Drupal\conflict\FieldComparatorManagerInterface
+   * @var FieldComparatorManagerInterface
    */
   protected $fieldComparatorManager;

@@ @@
   /**
    * The conflict manager.
    *
-   * @var \Drupal\conflict\ConflictResolver\ConflictResolverManagerInterface
+   * @var ConflictResolverManagerInterface
    */
   protected $conflictManager;

@@ @@
   /**
    * EntityConflictResolutionHandlerDefault constructor.
    *
-   * @param \Drupal\Core\Entity\EntityTypeInterface $entity_type
+   * @param EntityTypeInterface $entity_type
    *   The entity type.
-   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   * @param EntityTypeManagerInterface $entity_type_manager
    *   The entity type manager.
-   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
+   * @param ModuleHandlerInterface $module_handler
    *   The module handler.
-   * @param \Drupal\Core\KeyValueStore\KeyValueStoreInterface $key_value_original_entity
+   * @param KeyValueStoreInterface $key_value_original_entity
    *   The key value factory for storing the conflict original entity.
-   * @param \Drupal\conflict\FieldComparatorManagerInterface $field_comparator_manager
+   * @param FieldComparatorManagerInterface $field_comparator_manager
    *   The field comparator manager.
-   * @param \Drupal\conflict\ConflictResolver\ConflictResolverManagerInterface $conflict_manager
+   * @param ConflictResolverManagerInterface $conflict_manager
    *   The conflict manager.
    */
   public function __construct(EntityTypeInterface $entity_type, EntityTypeManagerInterface $entity_type_manager, ModuleHandlerInterface $module_handler, KeyValueStoreInterface $key_value_original_entity, FieldComparatorManagerInterface $field_comparator_manager, ConflictResolverManagerInterface $conflict_manager) {
@@ @@
    *
    * @param string $entity_type_id
    *   The entity type ID.
-   * @param \Drupal\Core\Entity\EntityInterface $entity
+   * @param EntityInterface $entity
    *   The entity.
    * @param $form
    *   The entity form.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The current state of the form.
    *
    * @see \Drupal\conflict\Entity\ContentEntityConflictHandler::entityFormAlter()
@@ @@

     if ($entity instanceof ContentEntityInterface && !$entity->isNew()) {
       if ($entity->isDefaultRevision()) {
-        /** @var \Drupal\Core\Entity\ContentEntityInterface $entity_server */
+        /** @var ContentEntityInterface $entity_server */
         $id = $entity->id();
         $entity_server = $this->storage->loadUnchanged($id);
       }
@@ @@
       $hash_path = $form['#parents'];
       $hash_path[] = 'conflict_entity_original_hash';
       $hash = NestedArray::getValue($input, $hash_path);
-      /** @var \Drupal\Core\Entity\ContentEntityInterface $entity_original */
+      /** @var ContentEntityInterface $entity_original */
       $entity_original = unserialize($this->keyValueOriginalEntity->get($hash));

       // Set the original entity as it might have changed. The original entity
@@ @@
       // Check if the entity requires a merge.
       $needs_merge = $this->needsMerge($entity, $entity_original, $entity_server, FALSE);
       if ($needs_merge) {
-        /** @var \Drupal\Core\Entity\Display\EntityFormDisplayInterface $form_display */
+        /** @var EntityFormDisplayInterface $form_display */
         $form_display = $form_state->getFormObject()
           ->getFormDisplay($form_state);

@@ @@
    *
    * @param array $form
    *   An associative array containing the structure of the form.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The current state of the form.
    *
    * @see \Drupal\conflict\Entity\ContentEntityConflictHandler::entityFormAlter()
@@ @@
     if (!$this->isFormLevelSubmission($form_state) || $form_state::hasAnyErrors() || empty($form_state->get('conflict.paths'))) {
       return;
     }
-    /** @var \Drupal\Core\Entity\ContentEntityFormInterface $form_object */
+    /** @var ContentEntityFormInterface $form_object */
     $form_object = $form_state->getFormObject();
     // Support https://www.drupal.org/node/2833682.
     if (method_exists($form_object, 'getIntermediateEntity')) {
@@ @@
    * return TRUE as there is no short way of checking for changes, in which case
    * the extended check should be performed afterwards.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_local_edited
+   * @param ContentEntityInterface $entity_local_edited
    *   The locally edited entity.
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_local_original
+   * @param ContentEntityInterface $entity_local_original
    *   The original not edited entity used to build the form.
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_server
+   * @param ContentEntityInterface $entity_server
    *   The unchanged entity loaded from the storage.
    * @param bool $extended_check
    *   Specifies whether an extended check should be performed.
@@ @@
       }
       if ($entity_local_edited instanceof EntityChangedInterface) {
         foreach ($entity_server_langcodes as $langcode) {
-          /** @var \Drupal\Core\Entity\EntityChangedInterface $entity_server_translation */
+          /** @var EntityChangedInterface $entity_server_translation */
           $entity_server_translation = $entity_server->getTranslation($langcode);
-          /** @var \Drupal\Core\Entity\EntityChangedInterface $entity_local_edited_translation */
+          /** @var EntityChangedInterface $entity_local_edited_translation */
           $entity_local_edited_translation = $entity_local_edited->getTranslation($langcode);
           if ($entity_server_translation->getChangedTime() != $entity_local_edited_translation->getChangedTime()) {
             return TRUE;
@@ @@
    * Additionally deleted translations will be removed and new translations will
    * be added.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_local_edited
+   * @param ContentEntityInterface $entity_local_edited
    *   The locally edited entity.
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_server
+   * @param ContentEntityInterface $entity_server
    *   The unchanged entity loaded from the storage.
    */
   protected function autoMergeNonEditedTranslations(ContentEntityInterface $entity_local_edited, ContentEntityInterface $entity_server) {
@@ @@
    * As non-editable fields are considered fields that are not contained in the
    * form display or the current user does not have edit access for them.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_local_edited
+   * @param ContentEntityInterface $entity_local_edited
    *   The locally edited entity.
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_server
+   * @param ContentEntityInterface $entity_server
    *   The unchanged entity loaded from the storage.
-   * @param \Drupal\Core\Entity\Display\EntityFormDisplayInterface $form_display
+   * @param EntityFormDisplayInterface $form_display
    *   The form display that the entity form operates with.
    */
   protected function autoMergeNonEditableFields(ContentEntityInterface $entity_local_edited, ContentEntityInterface $entity_server, EntityFormDisplayInterface $form_display) {
@@ @@
   /**
    * Merges non-touched fields i.e. prevents reverts.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_local_edited
+   * @param ContentEntityInterface $entity_local_edited
    *   The locally edited entity.
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_local_original
+   * @param ContentEntityInterface $entity_local_original
    *   The original not edited entity used to build the form.
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_server
+   * @param ContentEntityInterface $entity_server
    *   The unchanged entity loaded from the storage.
    * @param array $form
    *   The form array of the entity form. Might be used to retrieve the path to
    *   the entity in the form state values or user input.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The current state of the form. Might be used to alter the user input to
    *   reflect new metadata from the server entity.
    */
@@ @@
         // if we notify about an auto merge on that field. Therefore we ensure
         // that we notify the user only about auto merges on fields in the
         // current form.
-
-        /** @var \Drupal\Core\Entity\Display\EntityFormDisplayInterface $form_display */
+        /** @var EntityFormDisplayInterface $form_display */
         $form_display = $form_state->getFormObject()
           ->getFormDisplay($form_state);
         $auto_merged_untouched_fields_form = array_intersect($auto_merged_untouched_fields, array_keys($form_display->getComponents()));
@@ @@
    * be merged.
    * For revisionable entities the revision ID will be merged.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_local_edited
+   * @param ContentEntityInterface $entity_local_edited
    *   The locally edited entity.
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_server
+   * @param ContentEntityInterface $entity_server
    *   The unchanged entity loaded from the storage.
    * @param array $form
    *   The form array of the entity form. Might be used to retrieve the path to
    *   the entity in the form state values or user input.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The current state of the form. Might be used to alter the user input to
    *   reflect new metadata from the server entity.
    */
@@ @@
   /**
    * Checks whether there are conflicts.
    *
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_local_edited
+   * @param ContentEntityInterface $entity_local_edited
    *   The locally edited entity.
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_local_original
+   * @param ContentEntityInterface $entity_local_original
    *   The original not edited entity used to build the form.
-   * @param \Drupal\Core\Entity\ContentEntityInterface $entity_server
+   * @param ContentEntityInterface $entity_server
    *   The unchanged entity loaded from the storage.
    *
    * @return bool
-   *
    */
   protected function hasConflicts(ContentEntityInterface $entity_local_edited, ContentEntityInterface $entity_local_original, ContentEntityInterface $entity_server) {
     $entity_type_id = $this->entityType->id();
@@ @@
   /**
    * Determines if the form level submission has been triggered.
    *
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The current state of the form.
    *
    * @return bool
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


11) modules/contrib/conflict/src/Entity/ConflictUIResolverHandlerInterface.php:12

    ---------- begin diff ----------
@@ @@
    *
    * @param $build
    *   The render array to fill in the conflict resolution
-   * @param \Drupal\Core\Ajax\AjaxResponse $response
+   * @param AjaxResponse $response
    *   The ajax response.
    *
    * @return mixed
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


12) modules/contrib/conflict/src/ConflictResolver/ConflictResolverManagerInterface.php:12

    ---------- begin diff ----------
@@ @@
   /**
    * Resolves the conflicts between two entities based on their common parent.
    *
-   * @param \Drupal\Core\Entity\EntityInterface $local
+   * @param EntityInterface $local
    *   The local part of the comparision - for example the entity built of the
    *   user input on an entity form submission. This is basically the active
    *   entity object.
-   * @param \Drupal\Core\Entity\EntityInterface $remote
+   * @param EntityInterface $remote
    *   The remote part of the comparision - for example the current version of
    *   the entity from the storage or from a remote branch.
-   * @param \Drupal\Core\Entity\EntityInterface $base
+   * @param EntityInterface $base
    *   The initial entity version in concurrent editing or the lowest common
    *   ancestor in a revision tree scenario.
-   * @param \Drupal\Core\Entity\EntityInterface $result
+   * @param EntityInterface $result
    *   (optional) The result entity, on which to apply the result. Usually this
    *   will be the active entity object - the local entity. If none given, then
    *   the conflict resolutions will be applied on the local entity.
-   * @param \Symfony\Component\HttpFoundation\ParameterBag $context
+   * @param ParameterBag $context
    *   (optional) The context parameter bag.
    * @param array $conflicts
    *   (optional) The conflicts as returned by ::getConflicts() or a sub-set of
@@ @@
   /**
    * Returns the conflicts between two entities based on their common parent.
    *    *
-   * @param \Drupal\Core\Entity\EntityInterface $local
+   * @param EntityInterface $local
    *   The local part of the comparision - for example the entity built of the
    *   user input on an entity form submission. This is basically the active
    *   entity object.
-   * @param \Drupal\Core\Entity\EntityInterface $remote
+   * @param EntityInterface $remote
    *   The remote part of the comparision - for example the current version of
    *   the entity from the storage.
-   * @param \Drupal\Core\Entity\EntityInterface $base
+   * @param EntityInterface $base
    *   The initial entity version in concurrent editing or the lowest common
    *   ancestor in a revision tree scenario.
-   * @param \Symfony\Component\HttpFoundation\ParameterBag $context
+   * @param ParameterBag $context
    *   (optional) The context parameter bag.
    *
    * @return array
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector


13) modules/contrib/conflict/src/ConflictResolver/ConflictResolverManager.php:16

    ---------- begin diff ----------
@@ @@
   /**
    * The event dispatcher used to notify subscribers.
    *
-   * @var \Symfony\Component\EventDispatcher\EventDispatcherInterface
+   * @var EventDispatcherInterface
    */
   protected $eventDispatcher;

@@ @@
   /**
    * Constructs a new Conflict Resolver Manager.
    *
-   * @param \Symfony\Component\EventDispatcher\EventDispatcherInterface $event_dispatcher
+   * @param EventDispatcherInterface $event_dispatcher
    *   The event dispatcher used to notify subscribers of config import events.
    */
   public function __construct(EventDispatcherInterface $event_dispatcher) {
@@ @@
       $result = $result ?? $local;
       $event = new EntityConflictResolutionEvent($local, $remote, $base, $result, $conflicts, $context);
       // Fire an event to allow listeners to automatically resolve conflicts.
-      $this->eventDispatcher->dispatch(EntityConflictEvents::ENTITY_CONFLICT_RESOLVE, $event);
+      $this->eventDispatcher->dispatch($event, EntityConflictEvents::ENTITY_CONFLICT_RESOLVE);
       $conflicts = $event->getConflicts();
     }

@@ @@
     $event = new EntityConflictDiscoveryEvent($local, $remote, $base, $context);
     // Fire an event to allow listeners to build a list of conflicting
     // properties.
-    $this->eventDispatcher->dispatch(EntityConflictEvents::ENTITY_CONFLICT_DISCOVERY, $event);
+    $this->eventDispatcher->dispatch($event, EntityConflictEvents::ENTITY_CONFLICT_DISCOVERY);

     return $event->getConflicts();
   }
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * MakeDispatchFirstArgumentEventRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


14) modules/contrib/conflict/src/ConflictResolution/MergeStrategyInterface.php:28

    ---------- begin diff ----------
@@ @@
   /**
    * Checks whether this merge strategy is active for the conflict resolution.
    *
-   * @param \Drupal\conflict\Event\EntityConflictResolutionEvent $event
+   * @param EntityConflictResolutionEvent $event
    *   The conflict resolution event.
    *
    * @return bool
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector


15) modules/contrib/conflict/src/ConflictResolution/MergeRemoteOnlyChanges.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\conflict\ConflictResolution;

+use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\conflict\ConflictTypes;
 use Drupal\conflict\Event\EntityConflictResolutionEvent;

@@ @@
    * {@inheritdoc}
    */
   public function resolveConflictsContentEntity(EntityConflictResolutionEvent $event) {
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $remote_entity */
+    /** @var ContentEntityInterface $remote_entity */
     $remote_entity = $event->getRemoteEntity();
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $result_entity */
+    /** @var ContentEntityInterface $result_entity */
     $result_entity = $event->getResultEntity();

     foreach ($event->getConflicts() as $property => $conflict_type) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


16) modules/contrib/conflict/src/ConflictDiscovery/DefaultConflictDiscovery.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\conflict\ConflictDiscovery;

+use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\conflict\ConflictTypes;
 use Drupal\conflict\Event\EntityConflictDiscoveryEvent;

@@ @@
    * {@inheritdoc}
    */
   public function discoverConflictsContentEntity(EntityConflictDiscoveryEvent $event) {
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $local_entity */
+    /** @var ContentEntityInterface $local_entity */
     $local_entity = $event->getLocalEntity();
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $remote_entity */
+    /** @var ContentEntityInterface $remote_entity */
     $remote_entity = $event->getRemoteEntity();
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $base_entity */
+    /** @var ContentEntityInterface $base_entity */
     $base_entity = $event->getBaseEntity();

     $langcode = $local_entity->language()->getId();
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


17) modules/contrib/conflict/modules/conflict_paragraphs/src/Plugin/Conflict/FieldComparator/FieldComparatorParagraphReference.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\conflict_paragraphs\Plugin\Conflict\FieldComparator;

+use Drupal\Core\Entity\Display\EntityFormDisplayInterface;
+use Drupal\Core\Field\WidgetInterface;
 use Drupal\conflict\ConflictTypes;
 use Drupal\conflict\Entity\EntityConflictHandlerInterface;
 use Drupal\conflict\Plugin\Conflict\FieldComparator\FieldComparatorDefault;
@@ @@
   /**
    * The entity type manager.
    *
-   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   * @var EntityTypeManagerInterface
    */
   protected $entityTypeManager;

@@ @@
    *   The plugin_id for the widget.
    * @param mixed $plugin_definition
    *   The plugin implementation definition.
-   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   * @param EntityTypeManagerInterface $entity_type_manager
    *   The entity type manager.
    */
   public function __construct($plugin_id, $plugin_definition, EntityTypeManagerInterface $entity_type_manager) {
@@ @@
   /**
    * Returns the conflict type for common paragraphs.
    *
-   * @param \Drupal\Core\Field\FieldItemListInterface $local
+   * @param FieldItemListInterface $local
    *   The local field item list to compare.
-   * @param \Drupal\Core\Field\FieldItemListInterface $server
+   * @param FieldItemListInterface $server
    *   The server field item list to compare.
-   * @param \Drupal\Core\Field\FieldItemListInterface $original
+   * @param FieldItemListInterface $original
    *   The original field item list, from which local and the server emerged.
    *
    * @return string|null
@@ @@
   protected function getConflictTypeForCommonParagraphs(FieldItemListInterface $local, FieldItemListInterface $server, FieldItemListInterface $original) {
     $conflict_type = NULL;

-    /** @var \Drupal\conflict\Entity\EntityConflictHandlerInterface $entity_conflict_resolution_handler */
+    /** @var EntityConflictHandlerInterface $entity_conflict_resolution_handler */
     $entity_conflict_resolution_handler = $this->entityTypeManager->getHandler('paragraph', 'conflict.resolution_handler');

     foreach ($local as $local_item) {
@@ @@
       $local_item_target_id = $local_item->target_id;
       /** @var \Drupal\paragraphs\ParagraphInterface $local_item_entity */
       $local_item_entity = $local_item->entity;
-      /** @var \Drupal\Core\Entity\Display\EntityFormDisplayInterface $local_item_entity_form_display */
+      /** @var EntityFormDisplayInterface $local_item_entity_form_display */
       $local_item_entity_form_display = $local_item_entity->{EntityConflictHandlerInterface::CONFLICT_FORM_DISPLAY};

       $server_item_entity = NULL;
@@ @@
         }
       }

-      /** @var \Drupal\Core\Field\WidgetInterface $widget */
+      /** @var WidgetInterface $widget */
       $widget = $local->conflictWidget;
       if ($widget) {
         $removed_entity_form_display = EntityFormDisplay::collectRenderDisplay($original_item_entity, $widget->getSetting('form_display_mode'));
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


18) modules/contrib/conflict/modules/conflict_paragraphs/src/ConflictResolution/MergeRemoteStructure.php:1

    ---------- begin diff ----------
@@ @@

 namespace Drupal\conflict_paragraphs\ConflictResolution;

+use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\Component\Utility\NestedArray;
 use Drupal\conflict\ConflictResolution\MergeStrategyBase;
 use Drupal\conflict\Entity\EntityConflictHandlerInterface;
@@ @@
    * {@inheritdoc}
    */
   public function resolveConflictsContentEntity(EntityConflictResolutionEvent $event) {
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $local_entity */
+    /** @var ContentEntityInterface $local_entity */
     $local_entity = $event->getLocalEntity();
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $remote_entity */
+    /** @var ContentEntityInterface $remote_entity */
     $remote_entity = $event->getRemoteEntity();
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $original_entity */
+    /** @var ContentEntityInterface $original_entity */
     $original_entity = $event->getBaseEntity();
-    /** @var \Drupal\Core\Entity\ContentEntityInterface $result_entity */
+    /** @var ContentEntityInterface $result_entity */
     $result_entity = $event->getResultEntity();

-    /** @var \Drupal\Core\Form\FormStateInterface $form_state */
+    /** @var FormStateInterface $form_state */
     $form_state = $event->getContextParameter('form_state');

     // TODO this supports only paragraphs at first level.
@@ @@
   /**
    * Reorders the widget state for the reordered item list.
    *
-   * @param \Drupal\Core\Field\FieldItemListInterface $field_item_list
+   * @param FieldItemListInterface $field_item_list
    *   The reordered field item list.
-   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   * @param FormStateInterface $form_state
    *   The form state.
    */
   protected function reorderWidgetState(FieldItemListInterface $field_item_list, FormStateInterface $form_state) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector
 * PseudoNamespaceToNamespaceRector
 * WrapReturnRector
 * AddParamTypeDeclarationRector
 * ChangeMethodVisibilityRector


19) modules/contrib/conflict/modules/conflict_paragraphs/conflict_paragraphs.module:0

    ---------- begin diff ----------
@@ @@
 <?php

+use Drupal\Core\Entity\Display\EntityFormDisplayInterface;
+use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\Core\Form\FormStateInterface;
 use Drupal\conflict\Entity\EntityConflictHandlerInterface;
 use Drupal\paragraphs\Plugin\Field\FieldWidget\ParagraphsWidget;
@@ @@
   /** @var \Drupal\paragraphs\Plugin\Field\FieldWidget\ParagraphsWidget $widget */
   $widget = $context['widget'];
   $widget_state = $widget::getWidgetState($element['#field_parents'], $items->getName(), $form_state);
-  /** @var \Drupal\Core\Entity\Display\EntityFormDisplayInterface $form_display */
+  /** @var EntityFormDisplayInterface $form_display */
   $form_display = $widget_state['paragraphs'][$delta]['display'];

   $entity = $widget_state['paragraphs'][$delta]['entity'];
@@ @@
   if ($form_state->get('conflict.build_conflict_resolution_form')) {
     $manual_merge_conflicts = $form_state->get('manual-merge-conflicts');
     if ($manual_merge_conflicts) {
-      /** @var \Drupal\Core\Entity\ContentEntityInterface $entity */
+      /** @var ContentEntityInterface $entity */
       $entity = $form_state->getFormObject()->getEntity();
       foreach ($manual_merge_conflicts as $field_name => $conflict_data) {
         if (ParagraphsWidget::isApplicable($entity->getFieldDefinition($field_name)) && isset($form[$field_name]['conflict_resolution'])) {
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector


20) modules/contrib/conflict/conflict.module:0

    ---------- begin diff ----------
@@ @@
 <?php

+use Drupal\Core\Entity\ContentEntityFormInterface;
 /**
  * @file
  * The module that makes concurrent editing possible.
@@ @@
       $original_entity = \Drupal::keyValueExpirable('conflict_original_entity')->get($conflict_entity_original_hash);
       if ($original_entity) {
         $original_entity = unserialize($original_entity);
-        /** @var \Drupal\Core\Entity\EntityFormInterface $form_object */
+        /** @var EntityFormInterface $form_object */
         $form_object = $form_state->getFormObject();
         $form_object->setEntity($original_entity);
         $form_state->set('conflict-exchanged-entity', TRUE);
@@ @@
   $entity_type_manager = \Drupal::entityTypeManager();
   if ($entity_type_manager->hasHandler($entity_type_id, 'conflict.resolution_handler')) {
     if (!$inline_entity_form) {
-      /** @var \Drupal\Core\Entity\ContentEntityFormInterface $form_object */
+      /** @var ContentEntityFormInterface $form_object */
       $form_object = $form_state->getFormObject();
       $entity->{EntityConflictHandlerInterface::CONFLICT_FORM_DISPLAY} = $form_object->getFormDisplay($form_state);
     }

-    /** @var \Drupal\conflict\Entity\EntityConflictHandlerInterface $entity_conflict_resolution_handler */
+    /** @var EntityConflictHandlerInterface $entity_conflict_resolution_handler */
     $entity_conflict_resolution_handler = $entity_type_manager->getHandler($entity_type_id, 'conflict.resolution_handler');
     $entity_conflict_resolution_handler->entityFormAlter($form, $form_state, $entity, $inline_entity_form);
    ----------- end diff -----------

Applied rules:
 * ArgumentRemoverRector


21) modules/contrib/conflict/conflict.api.php:0

    ---------- begin diff ----------
@@ @@
 <?php

+use Drupal\Core\Form\FormStateInterface;
 /**
  * @file
  * Hooks and documentation related to conflict module.
  */
-
 /**
  * @defgroup conflict Conflict API
  *
@@ @@
  * Conflict module provides a way of merging concurrently edited entities.
  * @} End of "defgroup diff".
  */
-
 /**
  * @addtogroup hooks
  * @{
  */
-
 /**
  * Alter the conflict paths before the conflict resolution has started.
  *
@@ @@
  *   entity metadata consisting of
  *   -entity_type
  *   -entity_id
- * @param \Drupal\Core\Form\FormStateInterface $form_state
+ * @param FormStateInterface $form_state
  *   The main form state.
  */
-function hook_conflict_paths_alter(array &$conflict_paths, \Drupal\Core\Form\FormStateInterface $form_state) {}
+function hook_conflict_paths_alter(array &$conflict_paths, FormStateInterface $form_state) {}

 /**
  * @} End of "addtogroup hooks".
    ----------- end diff -----------

 [WARNING] 1 nodes were removed                                                 

 [OK] 21 files have been changed by Rector                                      

